Metadata-Version: 2.1
Name: fABBA
Version: 0.1.0
Summary: An efficient aggregation based symbolic representation
Home-page: https://github.com/nla-group/fABBA
Author: Stefan Guettel, Xinye Chen
Author-email: stefan.guettel@manchester.ac.uk
License: BSD 3-Clause
Platform: UNKNOWN
Description-Content-Type: text/markdown
License-File: LICENSE
Requires-Dist: numpy

fABBA
======================================

> An efficient aggregation based symbolic representation for temporal data


[![License](https://img.shields.io/badge/License-BSD%203--Clause-blue.svg)](https://opensource.org/licenses/BSD-3-Clause)


fABBA is a fast and accurate symbolic representation methods, which allows for data compression and mining. 
By replacing the k-means clustering used in ABBA with a sorting-based aggregation technique, fABBA thereby
avoid repeated within-cluster-sum-of-squares computations, and the computational complexity is significantly reduced.
Also, in contrast to the ABBA, fABBA does not require the number of time series symbols to be specified in
advance while achieves competing performance against ABBA and other symbolic methods. 


## Install
To install the current release
```
pip install fABBA
```


#### *Apply series compression*

```python
>>> import numpy as np
>>> from fABBA.symbolic_representation import fabba_model
>>> np.random.seed(1)
>>> N = 100
>>> ts = np.random.rand(N)
>>> fabba = fabba_model(tol=0.1, alpha=0.5, sorting='lexi', scl=1, verbose=1, max_len=np.inf, string_form=True)
>>> print(fabba)
fABBA({'_alpha': 0.5, '_sorting': '2-norm', '_tol': 0.1, '_scl': 1, '_verbose': 1, '_max_len': inf, '_string_form': True, '_n_jobs': 1})

>>> string = fabba.fit_transform(ts)
>>> print(string)
&"+"!'$#(",!")*$")%!"$-!%&#!#$#(#$."&!%!#/%!#!*0'!1!

>>> inverse_ts = fabba.inverse_transform(symbolic_tsf, ts[0]) # reconstructed time series

```

#### *Apply adaptively polygonal chian approximation*

```python
>>> from fABBA.chainApproximation import compress
>>> from fABBA.chainApproximation import inverse_compress
>>> np.random.seed(1)
>>> N = 100
>>> ts = np.random.rand(N)
>>> pieces = compress(ts, tol=0.1)
>>> inverse_ts = inverse_compress(pieces, ts[0])
```

#### *Apply aggregated digitization*

```python
>>> from fABBA.digitization import digitize
>>> from fABBA.digitization import inverse_digitize
>>> string, parameters = digitize(pieces, alpha=0.1, sorting='2-norm', scl=1) # pieces from aforementioned compression
>>> print(''.join(string))
,"-#!.%&/#0'"12(#34$&%5!67)$*(+8*9:";!<'+=>!)$?@A!B!

>>> inverse_pieces = inverse_digitize(string, parameters)
>>> inverse_ts = inverse_compress(inverse_pieces, ts[0])
```

#### *Image compression*
```python
>>> from fABBA.load_datasets import load_images
>>> from fABBA.symbolic_representation import image_compress
>>> from fABBA.symbolic_representation import image_decompress
>>> from fABBA.symbolic_representation import fabba_model
>>> from cv2 import resize
>>> img_samples = load_images(shape=(100,100)) # load fABBA image test samples
>>> img = resize(img_samples[0], (100, 100)) # select the first image for test
>>> fabba = fabba_model(tol=0.1, alpha=0.01, sorting='2-norm', scl=1, verbose=1, max_len=np.inf, string_form=True)
>>> strings = image_compress(fabba, img)
>>> inverse_img = image_decompress(fabba, strings)
```

## Authors

Stefan Guettel <stefan.guettel@manchester.ac.uk>

Xinye Chen <xinye.chen@manchester.ac.uk>




