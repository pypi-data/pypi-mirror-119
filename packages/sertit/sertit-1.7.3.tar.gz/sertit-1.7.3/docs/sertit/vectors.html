<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1"/>
<meta name="generator" content="pdoc 0.10.0"/>
<title>sertit.vectors API documentation</title>
<meta name="description" content="Vectors tools â€¦"/>
<link rel="preload stylesheet" as="style"
href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css"
integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style"
href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css"
integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style"
href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/darcula.min.css"
crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100%;padding:3em 4em;border-left:1px solid #ddd;overflow-x:hidden}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}table{display:block;overflow-x:auto;word-break:keep-all;border-collapse:separate;border-spacing:0}th{background-color:#c4d5e780;padding:5px;border-bottom:0.1px solid gray;border-right:0.1px solid gray;border-top:0.1px solid gray}td,th{margin:0}td{white-space:nowrap;border-bottom:0.1px solid gray;border-right:0.1px solid gray}td:empty{background-color:#ececec}th:nth-child(1){border-left:0.1px solid gray}td:nth-child(1){border-left:0.1px solid gray;border-right:0.1px solid gray}th:nth-child(1),td:nth-child(1){background-color:#c4d5e7;position:-webkit-sticky;position:sticky;left:0}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML"
integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"
integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sertit.vectors</code></h1>
</header>
<section id="section-intro">
<p>Vectors tools</p>
<p>You can use this only if you have installed sertit[full] or sertit[vectors]</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
# Copyright 2021, SERTIT-ICube - France, https://sertit.unistra.fr/
# This file is part of sertit-utils project
#     https://github.com/sertit/sertit-utils
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
&#34;&#34;&#34;
Vectors tools

You can use this only if you have installed sertit[full] or sertit[vectors]
&#34;&#34;&#34;
import logging
import os
import re
import shutil
import tarfile
import tempfile
import zipfile
from pathlib import Path
from typing import Any, Generator, Union

import numpy as np
import pandas as pd
from cloudpathlib import AnyPath, CloudPath
from cloudpathlib.exceptions import AnyPathTypeError
from fiona.errors import UnsupportedGeometryTypeError

from sertit import files, misc, strings

try:
    import geopandas as gpd
    from shapely import wkt
    from shapely.geometry import MultiPolygon, Polygon, box
except ModuleNotFoundError as ex:
    raise ModuleNotFoundError(
        &#34;Please install &#39;geopandas&#39; to use the rasters package.&#34;
    ) from ex

from sertit.logs import SU_NAME

LOGGER = logging.getLogger(SU_NAME)

WGS84 = &#34;EPSG:4326&#34;


def corresponding_utm_projection(lon: float, lat: float) -&gt; str:
    &#34;&#34;&#34;
    Find the EPSG code of the UTM projection from a lon/lat in WGS84.

    ```python
    &gt;&gt;&gt; corresponding_utm_projection(lon=7.8, lat=48.6)  # Strasbourg
    &#39;EPSG:32632&#39;
    ```

    Args:
        lon (float): Longitude (WGS84)
        lat (float): Latitude (WGS84)

    Returns:
        str: EPSG string

    &#34;&#34;&#34;
    # EPSG code begins with 32
    # Then 6 if north, 7 if south -&gt; (np.sign(lat) + 1) / 2 * 100 == 1 if lat &gt; 0 (north), 0 if lat &lt; 0 (south)
    # Then EPSG code with usual formula np.floor((180 + lon) / 6) + 1)
    epsg = int(32700 - (np.sign(lat) + 1) / 2 * 100 + np.floor((180 + lon) / 6) + 1)
    return f&#34;EPSG:{epsg}&#34;


def from_polygon_to_bounds(
    polygon: Union[Polygon, MultiPolygon]
) -&gt; (float, float, float, float):
    &#34;&#34;&#34;
    Convert a `shapely.polygon` to its bounds, sorted as `left, bottom, right, top`.

    ```python
    &gt;&gt;&gt; poly = Polygon(((0., 0.), (0., 1.), (1., 1.), (1., 0.), (0., 0.)))
    &gt;&gt;&gt; from_polygon_to_bounds(poly)
    (0.0, 0.0, 1.0, 1.0)
    ```

    Args:
        polygon (MultiPolygon): polygon to convert

    Returns:
        (float, float, float, float): left, bottom, right, top
    &#34;&#34;&#34;
    left = polygon.bounds[0]  # xmin
    bottom = polygon.bounds[1]  # ymin
    right = polygon.bounds[2]  # xmax
    top = polygon.bounds[3]  # ymax

    assert left &lt; right
    assert bottom &lt; top

    return left, bottom, right, top


def from_bounds_to_polygon(
    left: float, bottom: float, right: float, top: float
) -&gt; Polygon:
    &#34;&#34;&#34;
    Convert the bounds to a `shapely.polygon`.

    ```python
    &gt;&gt;&gt; poly = from_bounds_to_polygon(0.0, 0.0, 1.0, 1.0)
    &gt;&gt;&gt; print(poly)
    &#39;POLYGON ((1 0, 1 1, 0 1, 0 0, 1 0))&#39;
    ```

    Args:
        left (float): Left coordinates
        bottom (float): Bottom coordinates
        right (float): Right coordinates
        top (float): Top coordinates

    Returns:
        Polygon: Polygon corresponding to the bounds

    &#34;&#34;&#34;
    return box(min(left, right), min(top, bottom), max(left, right), max(top, bottom))


def get_geodf(
    geometry: Union[Polygon, list, gpd.GeoSeries], crs: str
) -&gt; gpd.GeoDataFrame:
    &#34;&#34;&#34;
    Get a GeoDataFrame from a geometry and a crs

    ```python
    &gt;&gt;&gt; poly = Polygon(((0., 0.), (0., 1.), (1., 1.), (1., 0.), (0., 0.)))
    &gt;&gt;&gt; geodf = get_geodf(poly, crs=WGS84)
    &gt;&gt;&gt; print(geodf)
                                                geometry
    0  POLYGON ((0.00000 0.00000, 0.00000 1.00000, 1....
    ```

    Args:
        geometry (Union[Polygon, list]): List of Polygons, or Polygon or bounds
        crs (str): CRS of the polygon

    Returns:
        gpd.GeoDataFrame: Geometry as a geodataframe
    &#34;&#34;&#34;
    if isinstance(geometry, list):
        if isinstance(geometry[0], Polygon):
            pass
        else:
            try:
                geometry = [from_bounds_to_polygon(*geometry)]
            except TypeError as ex:
                raise TypeError(
                    &#34;Give the extent as &#39;left&#39;, &#39;bottom&#39;, &#39;right&#39;, and &#39;top&#39;&#34;
                ) from ex
    elif isinstance(geometry, Polygon):
        geometry = [geometry]
    elif isinstance(geometry, gpd.GeoSeries):
        geometry = geometry.geometry
    else:
        raise TypeError(&#34;geometry should be a list or a Polygon.&#34;)

    return gpd.GeoDataFrame(geometry=geometry, crs=crs)


def set_kml_driver() -&gt; None:
    &#34;&#34;&#34;
    Set KML driver for Fiona data (use it at your own risks !)

    ```python
    &gt;&gt;&gt; path = &#34;path\\to\\kml.kml&#34;
    &gt;&gt;&gt; gpd.read_file(path)
    fiona.errors.DriverError: unsupported driver: &#39;LIBKML&#39;

    &gt;&gt;&gt; set_kml_driver()
    &gt;&gt;&gt; gpd.read_file(path)
                   Name  ...                                           geometry
    0  CC679_new_AOI2_3  ...  POLYGON Z ((45.03532 32.49765 0.00000, 46.1947...
    [1 rows x 12 columns]
    ```

    &#34;&#34;&#34;
    drivers = gpd.io.file.fiona.drvsupport.supported_drivers
    if &#34;LIBKML&#34; not in drivers:
        drivers[&#34;LIBKML&#34;] = &#34;rw&#34;
    if &#34;KML&#34; not in drivers:  # Just in case
        drivers[&#34;KML&#34;] = &#34;rw&#34;


def get_aoi_wkt(
    aoi_path: Union[str, CloudPath, Path], as_str: bool = True
) -&gt; Union[str, Polygon]:
    &#34;&#34;&#34;
    Get AOI formatted as a WKT from files that can be read by Fiona (like shapefiles, ...)
    or directly from a WKT file. The use of KML has been forced (use it at your own risks !).

    See: https://fiona.readthedocs.io/en/latest/fiona.html#fiona.open

    It is assessed that:

    - only **one** polygon composes the AOI (as only the first one is read)
    - it should be specified in lat/lon (WGS84) if a WKT file is provided
    ```python
    &gt;&gt;&gt; path = &#34;path\\to\\vec.geojson&#34;  # OK with ESRI Shapefile, geojson, WKT, KML...
    &gt;&gt;&gt; get_aoi_wkt(path)
    &#39;POLYGON Z ((46.1947755465253067 32.4973553439109324 0.0000000000000000, 45.0353174370802520 32.4976496856158974
    0.0000000000000000, 45.0355748149750283 34.1139970085580018 0.0000000000000000, 46.1956059695554089
    34.1144793800670882 0.0000000000000000, 46.1947755465253067 32.4973553439109324 0.0000000000000000))&#39;
    ```

    Args:
        aoi_path (Union[str, CloudPath, Path]): Absolute or relative path to an AOI.
            Its format should be WKT or any format read by Fiona, like shapefiles.
        as_str (bool): If True, return WKT as a str, otherwise as a shapely geometry

    Returns:
        Union[str, Polygon]: AOI formatted as a WKT stored in lat/lon
    &#34;&#34;&#34;
    aoi_path = AnyPath(aoi_path)
    if not aoi_path.is_file():
        raise FileNotFoundError(f&#34;AOI file {aoi_path} does not exist.&#34;)

    if aoi_path.suffix == &#34;.wkt&#34;:
        try:
            with open(aoi_path, &#34;r&#34;) as aoi_f:
                aoi = wkt.load(aoi_f)
        except Exception as ex:
            raise ValueError(&#34;AOI WKT cannot be read&#34;) from ex
    else:
        try:
            # Open file
            aoi_file = read(aoi_path, crs=WGS84)

            # Get envelope polygon
            geom = aoi_file[&#34;geometry&#34;]
            if len(geom) &gt; 1:
                LOGGER.warning(
                    &#34;Your AOI contains several polygons. Only the first will be treated !&#34;
                )
            polygon = geom[0].convex_hull

            # Convert to WKT
            aoi = wkt.loads(str(polygon))

        except Exception as ex:
            raise ValueError(&#34;AOI cannot be read by Fiona&#34;) from ex

    # Convert to string if needed
    if as_str:
        aoi = wkt.dumps(aoi)

    LOGGER.debug(&#34;Specified AOI in WKT: %s&#34;, aoi)
    return aoi


def get_wider_exterior(vector: gpd.GeoDataFrame) -&gt; gpd.GeoDataFrame:
    &#34;&#34;&#34;
    Get the wider exterior of a MultiPolygon as a Polygon
    Args:
        vector (vector: gpd.GeoDataFrame): Polygon to simplify

    Returns:
        vector: gpd.GeoDataFrame: Wider exterior
    &#34;&#34;&#34;

    # Get the footprint max (discard small holes stored in other polygons)
    wider = vector[vector.area == np.max(vector.area)]

    # Only select the exterior of this footprint(sometimes some holes persist)
    if not wider.empty:
        poly = Polygon(list(wider.exterior.iat[0].coords))
        wider = gpd.GeoDataFrame(geometry=[poly], crs=wider.crs)

        # Resets index as we only got one polygon left which should have index 0
        wider.reset_index(inplace=True)

    return wider


def _to_polygons(val: Any) -&gt; Polygon:
    &#34;&#34;&#34;
    Convert to polygon (to be used in pandas) -&gt; convert the geometry column

    Args:
        val (Any): Pandas value that has a &#34;coordinates&#34; field

    Returns:
        Polygon: Pandas value as a Polygon
    &#34;&#34;&#34;
    # Donut cases
    if len(val[&#34;coordinates&#34;]) &gt; 1:
        poly = Polygon(val[&#34;coordinates&#34;][0], val[&#34;coordinates&#34;][1:])
    else:
        poly = Polygon(val[&#34;coordinates&#34;][0])

    # Note: it doesn&#39;t check if polygons are valid or not !
    # If needed, do:
    # if not poly.is_valid:
    #   poly = poly.buffer(1.0E-9)
    return poly


def shapes_to_gdf(shapes: Generator, crs: str):
    &#34;&#34;&#34;
    Convert rasterio shapes to geodataframe

    Args:
        shapes (Generator): Shapes from rasterio
        crs: Wanted CRS of the vector. If None, using naive or origin CRS.
    Returns:
        gpd.GeoDataFrame: Shapes as a GeoDataFrame
    &#34;&#34;&#34;
    # Convert results to pandas (because of invalid geometries) and save it
    pd_results = pd.DataFrame(shapes, columns=[&#34;geometry&#34;, &#34;raster_val&#34;])

    if not pd_results.empty:
        # Convert to proper polygons(correct geometries)
        pd_results.geometry = pd_results.geometry.apply(_to_polygons)

    # Convert to geodataframe with correct geometry
    return gpd.GeoDataFrame(pd_results, geometry=pd_results.geometry, crs=crs)


def read(
    path: Union[str, CloudPath, Path], crs: Any = None, archive_regex: str = None
) -&gt; gpd.GeoDataFrame:
    &#34;&#34;&#34;
    Read any vector:
    - if KML: sets correctly the drivers and open layered KML (you may need `ogr2ogr` to make it work !)
    - if archive (only zip or tar), use a regex to look for the vector inside the archive.
        You can use this [site](https://regexr.com/) to build your regex.
    - if GML: manages the empty errors

    ```python
    &gt;&gt;&gt; # Usual
    &gt;&gt;&gt; path = &#39;D:\\path\\to\\vector.geojson&#39;
    &gt;&gt;&gt; vectors.read(path, crs=WGS84)
                           Name  ...                                           geometry
    0  Sentinel-1 Image Overlay  ...  POLYGON ((0.85336 42.24660, -2.32032 42.65493,...

    &gt;&gt;&gt; # Archive
    &gt;&gt;&gt; arch_path = &#39;D:\\path\\to\\zip.zip&#39;
    &gt;&gt;&gt; vectors.read(arch_path, archive_regex=&#34;.*map-overlay\.kml&#34;)
                           Name  ...                                           geometry
    0  Sentinel-1 Image Overlay  ...  POLYGON ((0.85336 42.24660, -2.32032 42.65493,...
    ```

    Args:
        path (Union[str, CloudPath, Path]): Path to vector to read. In case of archive, path to the archive.
        crs: Wanted CRS of the vector. If None, using naive or origin CRS.
        archive_regex (str): [Archive only] Regex for the wanted vector inside the archive

    Returns:
        gpd.GeoDataFrame: Read vector as a GeoDataFrame
    &#34;&#34;&#34;
    tmp_dir = None
    arch_vect_path = None
    try:
        path = AnyPath(path)

        # Load vector in cache if needed (geopandas do not use correctly S3 paths for now)
        if isinstance(path, CloudPath):
            tmp_dir = tempfile.TemporaryDirectory()
            if path.suffix == &#34;.shp&#34;:
                # Download everything to disk
                for shp_file in path.parent.glob(path.with_suffix(&#34;.*&#34;).name):
                    cached_path = shp_file.download_to(tmp_dir.name)
                    if cached_path.suffix == &#34;.shp&#34;:
                        path = cached_path
            else:
                path = AnyPath(path.fspath)

        # Manage archive case
        if path.suffix in [&#34;.tar&#34;, &#34;.zip&#34;]:
            prefix = path.suffix[-3:]
            file_list = files.get_archived_file_list(path)

            try:
                regex = re.compile(archive_regex)
                arch_vect_path = list(filter(regex.match, file_list))[0]

                if isinstance(path, CloudPath):
                    vect_path = f&#34;{prefix}+{path}!{arch_vect_path}&#34;
                else:
                    vect_path = f&#34;{prefix}://{path}!{arch_vect_path}&#34;
            except IndexError:
                raise FileNotFoundError(
                    f&#34;Impossible to find vector {archive_regex} in {files.get_filename(path)}&#34;
                )
        elif path.suffixes == [&#34;.tar&#34;, &#34;.gz&#34;]:
            raise TypeError(
                &#34;.tar.gz files are too slow to read from inside the archive. Please extract them instead.&#34;
            )
        else:
            vect_path = str(path)
    except AnyPathTypeError:
        vect_path = str(path)

    # Open vector
    try:
        # Discard some weird error concerning a NULL pointer that outputs a ValueError (as we already except it)
        fiona_logger = logging.getLogger(&#34;fiona&#34;)
        fiona_logger.setLevel(logging.CRITICAL)

        # Read mask

        # Manage KML driver
        if vect_path.endswith(&#34;.kml&#34;):
            set_kml_driver()
            vect = gpd.GeoDataFrame()

            # Document tags in KML file are separate layers for GeoPandas.
            # When you try to get the KML content, you actually get the first layer.
            # So you need for loop for iterating over layers.
            # https://gis.stackexchange.com/questions/328525/geopandas-read-file-only-reading-first-part-of-kml/328554
            import fiona

            for layer in fiona.listlayers(vect_path):
                try:
                    vect_layer = gpd.read_file(vect_path, driver=&#34;KML&#34;, layer=layer)
                    if not vect_layer.empty:
                        # KML files are always in WGS84 (and does not contain this information)
                        vect_layer.crs = WGS84
                        vect = vect.append(vect_layer, ignore_index=True)
                except ValueError:
                    pass  # Except Null Layer

            # Workaround for archived KML -&gt; they may be empty
            # Convert KML to GeoJSON
            if vect.empty and shutil.which(&#34;ogr2ogr&#34;):  # Needs ogr2ogr here
                if not tmp_dir:
                    tmp_dir = tempfile.TemporaryDirectory()
                if path.suffix == &#34;.zip&#34;:
                    with zipfile.ZipFile(path, &#34;r&#34;) as zip_ds:
                        vect_path = zip_ds.extract(arch_vect_path, tmp_dir.name)
                elif path.suffix == &#34;.tar&#34;:
                    with tarfile.open(path, &#34;r&#34;) as tar_ds:
                        tar_ds.extract(arch_vect_path, tmp_dir.name)
                        vect_path = os.path.join(tmp_dir.name, arch_vect_path)

                vect_path_gj = os.path.join(
                    tmp_dir.name, os.path.basename(vect_path).replace(&#34;kml&#34;, &#34;geojson&#34;)
                )
                cmd_line = [
                    &#34;ogr2ogr&#34;,
                    &#34;-fieldTypeToString DateTime&#34;,  # Disable warning
                    &#34;-f GeoJSON&#34;,
                    strings.to_cmd_string(vect_path_gj),  # dst
                    strings.to_cmd_string(vect_path),  # src
                ]
                try:
                    misc.run_cli(cmd_line)
                except RuntimeError as ex:
                    raise RuntimeError(
                        f&#34;Something went wrong with ogr2ogr: {ex}&#34;
                    ) from ex

                # Open the geojson
                vect = gpd.read_file(vect_path_gj)
            else:
                vect.crs = WGS84  # Force set CRS to whole vector
        else:
            vect = gpd.read_file(vect_path)

        # Manage naive geometries
        if vect.crs and crs:
            vect = vect.to_crs(crs)

        # Set fiona logger back to what it was
        fiona_logger.setLevel(logging.INFO)
    except (ValueError, UnsupportedGeometryTypeError) as ex:
        # Do not print warning for null layer
        if &#34;Null layer&#34; not in str(ex):
            LOGGER.warning(ex)
        vect = gpd.GeoDataFrame(geometry=[], crs=crs)

    # Clean
    if tmp_dir:
        tmp_dir.cleanup()

    return vect</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sertit.vectors.corresponding_utm_projection"><code class="name flex">
<p>def <span class="ident">corresponding_utm_projection</span>(</p><p>lon, <br>lat)</p>
</code></dt>
<dd>
<div class="desc"><p>Find the EPSG code of the UTM projection from a lon/lat in WGS84.</p>
<pre><code class="language-python">&gt;&gt;&gt; corresponding_utm_projection(lon=7.8, lat=48.6)  # Strasbourg
'EPSG:32632'
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>lon</code></strong> :&ensp;<code>float</code></dt>
<dd>Longitude (WGS84)</dd>
<dt><strong><code>lat</code></strong> :&ensp;<code>float</code></dt>
<dd>Latitude (WGS84)</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>EPSG string</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def corresponding_utm_projection(lon: float, lat: float) -&gt; str:
    &#34;&#34;&#34;
    Find the EPSG code of the UTM projection from a lon/lat in WGS84.

    ```python
    &gt;&gt;&gt; corresponding_utm_projection(lon=7.8, lat=48.6)  # Strasbourg
    &#39;EPSG:32632&#39;
    ```

    Args:
        lon (float): Longitude (WGS84)
        lat (float): Latitude (WGS84)

    Returns:
        str: EPSG string

    &#34;&#34;&#34;
    # EPSG code begins with 32
    # Then 6 if north, 7 if south -&gt; (np.sign(lat) + 1) / 2 * 100 == 1 if lat &gt; 0 (north), 0 if lat &lt; 0 (south)
    # Then EPSG code with usual formula np.floor((180 + lon) / 6) + 1)
    epsg = int(32700 - (np.sign(lat) + 1) / 2 * 100 + np.floor((180 + lon) / 6) + 1)
    return f&#34;EPSG:{epsg}&#34;</code></pre>
</details>
</dd>
<dt id="sertit.vectors.from_polygon_to_bounds"><code class="name flex">
<p>def <span class="ident">from_polygon_to_bounds</span>(</p><p>polygon)</p>
</code></dt>
<dd>
<div class="desc"><p>Convert a <code>shapely.polygon</code> to its bounds, sorted as <code>left, bottom, right, top</code>.</p>
<pre><code class="language-python">&gt;&gt;&gt; poly = Polygon(((0., 0.), (0., 1.), (1., 1.), (1., 0.), (0., 0.)))
&gt;&gt;&gt; from_polygon_to_bounds(poly)
(0.0, 0.0, 1.0, 1.0)
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>polygon</code></strong> :&ensp;<code>MultiPolygon</code></dt>
<dd>polygon to convert</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(float, float, float, float): left, bottom, right, top</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_polygon_to_bounds(
    polygon: Union[Polygon, MultiPolygon]
) -&gt; (float, float, float, float):
    &#34;&#34;&#34;
    Convert a `shapely.polygon` to its bounds, sorted as `left, bottom, right, top`.

    ```python
    &gt;&gt;&gt; poly = Polygon(((0., 0.), (0., 1.), (1., 1.), (1., 0.), (0., 0.)))
    &gt;&gt;&gt; from_polygon_to_bounds(poly)
    (0.0, 0.0, 1.0, 1.0)
    ```

    Args:
        polygon (MultiPolygon): polygon to convert

    Returns:
        (float, float, float, float): left, bottom, right, top
    &#34;&#34;&#34;
    left = polygon.bounds[0]  # xmin
    bottom = polygon.bounds[1]  # ymin
    right = polygon.bounds[2]  # xmax
    top = polygon.bounds[3]  # ymax

    assert left &lt; right
    assert bottom &lt; top

    return left, bottom, right, top</code></pre>
</details>
</dd>
<dt id="sertit.vectors.from_bounds_to_polygon"><code class="name flex">
<p>def <span class="ident">from_bounds_to_polygon</span>(</p><p>left, <br>bottom, <br>right, <br>top)</p>
</code></dt>
<dd>
<div class="desc"><p>Convert the bounds to a <code>shapely.polygon</code>.</p>
<pre><code class="language-python">&gt;&gt;&gt; poly = from_bounds_to_polygon(0.0, 0.0, 1.0, 1.0)
&gt;&gt;&gt; print(poly)
'POLYGON ((1 0, 1 1, 0 1, 0 0, 1 0))'
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>left</code></strong> :&ensp;<code>float</code></dt>
<dd>Left coordinates</dd>
<dt><strong><code>bottom</code></strong> :&ensp;<code>float</code></dt>
<dd>Bottom coordinates</dd>
<dt><strong><code>right</code></strong> :&ensp;<code>float</code></dt>
<dd>Right coordinates</dd>
<dt><strong><code>top</code></strong> :&ensp;<code>float</code></dt>
<dd>Top coordinates</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Polygon</code></dt>
<dd>Polygon corresponding to the bounds</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def from_bounds_to_polygon(
    left: float, bottom: float, right: float, top: float
) -&gt; Polygon:
    &#34;&#34;&#34;
    Convert the bounds to a `shapely.polygon`.

    ```python
    &gt;&gt;&gt; poly = from_bounds_to_polygon(0.0, 0.0, 1.0, 1.0)
    &gt;&gt;&gt; print(poly)
    &#39;POLYGON ((1 0, 1 1, 0 1, 0 0, 1 0))&#39;
    ```

    Args:
        left (float): Left coordinates
        bottom (float): Bottom coordinates
        right (float): Right coordinates
        top (float): Top coordinates

    Returns:
        Polygon: Polygon corresponding to the bounds

    &#34;&#34;&#34;
    return box(min(left, right), min(top, bottom), max(left, right), max(top, bottom))</code></pre>
</details>
</dd>
<dt id="sertit.vectors.get_geodf"><code class="name flex">
<p>def <span class="ident">get_geodf</span>(</p><p>geometry, <br>crs)</p>
</code></dt>
<dd>
<div class="desc"><p>Get a GeoDataFrame from a geometry and a crs</p>
<pre><code class="language-python">&gt;&gt;&gt; poly = Polygon(((0., 0.), (0., 1.), (1., 1.), (1., 0.), (0., 0.)))
&gt;&gt;&gt; geodf = get_geodf(poly, crs=WGS84)
&gt;&gt;&gt; print(geodf)
                                            geometry
0  POLYGON ((0.00000 0.00000, 0.00000 1.00000, 1....
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>geometry</code></strong> :&ensp;<code>Union[Polygon, list]</code></dt>
<dd>List of Polygons, or Polygon or bounds</dd>
<dt><strong><code>crs</code></strong> :&ensp;<code>str</code></dt>
<dd>CRS of the polygon</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>gpd.GeoDataFrame</code></dt>
<dd>Geometry as a geodataframe</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_geodf(
    geometry: Union[Polygon, list, gpd.GeoSeries], crs: str
) -&gt; gpd.GeoDataFrame:
    &#34;&#34;&#34;
    Get a GeoDataFrame from a geometry and a crs

    ```python
    &gt;&gt;&gt; poly = Polygon(((0., 0.), (0., 1.), (1., 1.), (1., 0.), (0., 0.)))
    &gt;&gt;&gt; geodf = get_geodf(poly, crs=WGS84)
    &gt;&gt;&gt; print(geodf)
                                                geometry
    0  POLYGON ((0.00000 0.00000, 0.00000 1.00000, 1....
    ```

    Args:
        geometry (Union[Polygon, list]): List of Polygons, or Polygon or bounds
        crs (str): CRS of the polygon

    Returns:
        gpd.GeoDataFrame: Geometry as a geodataframe
    &#34;&#34;&#34;
    if isinstance(geometry, list):
        if isinstance(geometry[0], Polygon):
            pass
        else:
            try:
                geometry = [from_bounds_to_polygon(*geometry)]
            except TypeError as ex:
                raise TypeError(
                    &#34;Give the extent as &#39;left&#39;, &#39;bottom&#39;, &#39;right&#39;, and &#39;top&#39;&#34;
                ) from ex
    elif isinstance(geometry, Polygon):
        geometry = [geometry]
    elif isinstance(geometry, gpd.GeoSeries):
        geometry = geometry.geometry
    else:
        raise TypeError(&#34;geometry should be a list or a Polygon.&#34;)

    return gpd.GeoDataFrame(geometry=geometry, crs=crs)</code></pre>
</details>
</dd>
<dt id="sertit.vectors.set_kml_driver"><code class="name flex">
<p>def <span class="ident">set_kml_driver</span>(</p><p>)</p>
</code></dt>
<dd>
<div class="desc"><p>Set KML driver for Fiona data (use it at your own risks !)</p>
<pre><code class="language-python">&gt;&gt;&gt; path = &quot;path\to\kml.kml&quot;
&gt;&gt;&gt; gpd.read_file(path)
fiona.errors.DriverError: unsupported driver: 'LIBKML'

&gt;&gt;&gt; set_kml_driver()
&gt;&gt;&gt; gpd.read_file(path)
               Name  ...                                           geometry
0  CC679_new_AOI2_3  ...  POLYGON Z ((45.03532 32.49765 0.00000, 46.1947...
[1 rows x 12 columns]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_kml_driver() -&gt; None:
    &#34;&#34;&#34;
    Set KML driver for Fiona data (use it at your own risks !)

    ```python
    &gt;&gt;&gt; path = &#34;path\\to\\kml.kml&#34;
    &gt;&gt;&gt; gpd.read_file(path)
    fiona.errors.DriverError: unsupported driver: &#39;LIBKML&#39;

    &gt;&gt;&gt; set_kml_driver()
    &gt;&gt;&gt; gpd.read_file(path)
                   Name  ...                                           geometry
    0  CC679_new_AOI2_3  ...  POLYGON Z ((45.03532 32.49765 0.00000, 46.1947...
    [1 rows x 12 columns]
    ```

    &#34;&#34;&#34;
    drivers = gpd.io.file.fiona.drvsupport.supported_drivers
    if &#34;LIBKML&#34; not in drivers:
        drivers[&#34;LIBKML&#34;] = &#34;rw&#34;
    if &#34;KML&#34; not in drivers:  # Just in case
        drivers[&#34;KML&#34;] = &#34;rw&#34;</code></pre>
</details>
</dd>
<dt id="sertit.vectors.get_aoi_wkt"><code class="name flex">
<p>def <span class="ident">get_aoi_wkt</span>(</p><p>aoi_path, <br>as_str=True)</p>
</code></dt>
<dd>
<div class="desc"><p>Get AOI formatted as a WKT from files that can be read by Fiona (like shapefiles, &hellip;)
or directly from a WKT file. The use of KML has been forced (use it at your own risks !).</p>
<p>See: <a href="https://fiona.readthedocs.io/en/latest/fiona.html#fiona.open">https://fiona.readthedocs.io/en/latest/fiona.html#fiona.open</a></p>
<p>It is assessed that:</p>
<ul>
<li>only <strong>one</strong> polygon composes the AOI (as only the first one is read)</li>
<li>it should be specified in lat/lon (WGS84) if a WKT file is provided</li>
</ul>
<pre><code class="language-python">&gt;&gt;&gt; path = &quot;path\to\vec.geojson&quot;  # OK with ESRI Shapefile, geojson, WKT, KML...
&gt;&gt;&gt; get_aoi_wkt(path)
'POLYGON Z ((46.1947755465253067 32.4973553439109324 0.0000000000000000, 45.0353174370802520 32.4976496856158974
0.0000000000000000, 45.0355748149750283 34.1139970085580018 0.0000000000000000, 46.1956059695554089
34.1144793800670882 0.0000000000000000, 46.1947755465253067 32.4973553439109324 0.0000000000000000))'
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>aoi_path</code></strong> :&ensp;<code>Union[str, CloudPath, Path]</code></dt>
<dd>Absolute or relative path to an AOI.
Its format should be WKT or any format read by Fiona, like shapefiles.</dd>
<dt><strong><code>as_str</code></strong> :&ensp;<code>bool</code></dt>
<dd>If True, return WKT as a str, otherwise as a shapely geometry</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Union[str, Polygon]</code></dt>
<dd>AOI formatted as a WKT stored in lat/lon</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_aoi_wkt(
    aoi_path: Union[str, CloudPath, Path], as_str: bool = True
) -&gt; Union[str, Polygon]:
    &#34;&#34;&#34;
    Get AOI formatted as a WKT from files that can be read by Fiona (like shapefiles, ...)
    or directly from a WKT file. The use of KML has been forced (use it at your own risks !).

    See: https://fiona.readthedocs.io/en/latest/fiona.html#fiona.open

    It is assessed that:

    - only **one** polygon composes the AOI (as only the first one is read)
    - it should be specified in lat/lon (WGS84) if a WKT file is provided
    ```python
    &gt;&gt;&gt; path = &#34;path\\to\\vec.geojson&#34;  # OK with ESRI Shapefile, geojson, WKT, KML...
    &gt;&gt;&gt; get_aoi_wkt(path)
    &#39;POLYGON Z ((46.1947755465253067 32.4973553439109324 0.0000000000000000, 45.0353174370802520 32.4976496856158974
    0.0000000000000000, 45.0355748149750283 34.1139970085580018 0.0000000000000000, 46.1956059695554089
    34.1144793800670882 0.0000000000000000, 46.1947755465253067 32.4973553439109324 0.0000000000000000))&#39;
    ```

    Args:
        aoi_path (Union[str, CloudPath, Path]): Absolute or relative path to an AOI.
            Its format should be WKT or any format read by Fiona, like shapefiles.
        as_str (bool): If True, return WKT as a str, otherwise as a shapely geometry

    Returns:
        Union[str, Polygon]: AOI formatted as a WKT stored in lat/lon
    &#34;&#34;&#34;
    aoi_path = AnyPath(aoi_path)
    if not aoi_path.is_file():
        raise FileNotFoundError(f&#34;AOI file {aoi_path} does not exist.&#34;)

    if aoi_path.suffix == &#34;.wkt&#34;:
        try:
            with open(aoi_path, &#34;r&#34;) as aoi_f:
                aoi = wkt.load(aoi_f)
        except Exception as ex:
            raise ValueError(&#34;AOI WKT cannot be read&#34;) from ex
    else:
        try:
            # Open file
            aoi_file = read(aoi_path, crs=WGS84)

            # Get envelope polygon
            geom = aoi_file[&#34;geometry&#34;]
            if len(geom) &gt; 1:
                LOGGER.warning(
                    &#34;Your AOI contains several polygons. Only the first will be treated !&#34;
                )
            polygon = geom[0].convex_hull

            # Convert to WKT
            aoi = wkt.loads(str(polygon))

        except Exception as ex:
            raise ValueError(&#34;AOI cannot be read by Fiona&#34;) from ex

    # Convert to string if needed
    if as_str:
        aoi = wkt.dumps(aoi)

    LOGGER.debug(&#34;Specified AOI in WKT: %s&#34;, aoi)
    return aoi</code></pre>
</details>
</dd>
<dt id="sertit.vectors.get_wider_exterior"><code class="name flex">
<p>def <span class="ident">get_wider_exterior</span>(</p><p>vector)</p>
</code></dt>
<dd>
<div class="desc"><p>Get the wider exterior of a MultiPolygon as a Polygon</p>
<h2 id="args">Args</h2>
<p>vector (vector: gpd.GeoDataFrame): Polygon to simplify</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>vector</code></dt>
<dd>gpd.GeoDataFrame: Wider exterior</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_wider_exterior(vector: gpd.GeoDataFrame) -&gt; gpd.GeoDataFrame:
    &#34;&#34;&#34;
    Get the wider exterior of a MultiPolygon as a Polygon
    Args:
        vector (vector: gpd.GeoDataFrame): Polygon to simplify

    Returns:
        vector: gpd.GeoDataFrame: Wider exterior
    &#34;&#34;&#34;

    # Get the footprint max (discard small holes stored in other polygons)
    wider = vector[vector.area == np.max(vector.area)]

    # Only select the exterior of this footprint(sometimes some holes persist)
    if not wider.empty:
        poly = Polygon(list(wider.exterior.iat[0].coords))
        wider = gpd.GeoDataFrame(geometry=[poly], crs=wider.crs)

        # Resets index as we only got one polygon left which should have index 0
        wider.reset_index(inplace=True)

    return wider</code></pre>
</details>
</dd>
<dt id="sertit.vectors.shapes_to_gdf"><code class="name flex">
<p>def <span class="ident">shapes_to_gdf</span>(</p><p>shapes, <br>crs)</p>
</code></dt>
<dd>
<div class="desc"><p>Convert rasterio shapes to geodataframe</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>shapes</code></strong> :&ensp;<code>Generator</code></dt>
<dd>Shapes from rasterio</dd>
<dt><strong><code>crs</code></strong></dt>
<dd>Wanted CRS of the vector. If None, using naive or origin CRS.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>gpd.GeoDataFrame</code></dt>
<dd>Shapes as a GeoDataFrame</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shapes_to_gdf(shapes: Generator, crs: str):
    &#34;&#34;&#34;
    Convert rasterio shapes to geodataframe

    Args:
        shapes (Generator): Shapes from rasterio
        crs: Wanted CRS of the vector. If None, using naive or origin CRS.
    Returns:
        gpd.GeoDataFrame: Shapes as a GeoDataFrame
    &#34;&#34;&#34;
    # Convert results to pandas (because of invalid geometries) and save it
    pd_results = pd.DataFrame(shapes, columns=[&#34;geometry&#34;, &#34;raster_val&#34;])

    if not pd_results.empty:
        # Convert to proper polygons(correct geometries)
        pd_results.geometry = pd_results.geometry.apply(_to_polygons)

    # Convert to geodataframe with correct geometry
    return gpd.GeoDataFrame(pd_results, geometry=pd_results.geometry, crs=crs)</code></pre>
</details>
</dd>
<dt id="sertit.vectors.read"><code class="name flex">
<p>def <span class="ident">read</span>(</p><p>path, <br>crs=None, <br>archive_regex=None)</p>
</code></dt>
<dd>
<div class="desc"><p>Read any vector:
- if KML: sets correctly the drivers and open layered KML (you may need <code>ogr2ogr</code> to make it work !)
- if archive (only zip or tar), use a regex to look for the vector inside the archive.
You can use this <a href="https://regexr.com/">site</a> to build your regex.
- if GML: manages the empty errors</p>
<pre><code class="language-python">&gt;&gt;&gt; # Usual
&gt;&gt;&gt; path = 'D:\path\to\vector.geojson'
&gt;&gt;&gt; vectors.read(path, crs=WGS84)
                       Name  ...                                           geometry
0  Sentinel-1 Image Overlay  ...  POLYGON ((0.85336 42.24660, -2.32032 42.65493,...

&gt;&gt;&gt; # Archive
&gt;&gt;&gt; arch_path = 'D:\path\to\zip.zip'
&gt;&gt;&gt; vectors.read(arch_path, archive_regex=&quot;.*map-overlay\.kml&quot;)
                       Name  ...                                           geometry
0  Sentinel-1 Image Overlay  ...  POLYGON ((0.85336 42.24660, -2.32032 42.65493,...
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>Union[str, CloudPath, Path]</code></dt>
<dd>Path to vector to read. In case of archive, path to the archive.</dd>
<dt><strong><code>crs</code></strong></dt>
<dd>Wanted CRS of the vector. If None, using naive or origin CRS.</dd>
<dt><strong><code>archive_regex</code></strong> :&ensp;<code>str</code></dt>
<dd>[Archive only] Regex for the wanted vector inside the archive</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>gpd.GeoDataFrame</code></dt>
<dd>Read vector as a GeoDataFrame</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read(
    path: Union[str, CloudPath, Path], crs: Any = None, archive_regex: str = None
) -&gt; gpd.GeoDataFrame:
    &#34;&#34;&#34;
    Read any vector:
    - if KML: sets correctly the drivers and open layered KML (you may need `ogr2ogr` to make it work !)
    - if archive (only zip or tar), use a regex to look for the vector inside the archive.
        You can use this [site](https://regexr.com/) to build your regex.
    - if GML: manages the empty errors

    ```python
    &gt;&gt;&gt; # Usual
    &gt;&gt;&gt; path = &#39;D:\\path\\to\\vector.geojson&#39;
    &gt;&gt;&gt; vectors.read(path, crs=WGS84)
                           Name  ...                                           geometry
    0  Sentinel-1 Image Overlay  ...  POLYGON ((0.85336 42.24660, -2.32032 42.65493,...

    &gt;&gt;&gt; # Archive
    &gt;&gt;&gt; arch_path = &#39;D:\\path\\to\\zip.zip&#39;
    &gt;&gt;&gt; vectors.read(arch_path, archive_regex=&#34;.*map-overlay\.kml&#34;)
                           Name  ...                                           geometry
    0  Sentinel-1 Image Overlay  ...  POLYGON ((0.85336 42.24660, -2.32032 42.65493,...
    ```

    Args:
        path (Union[str, CloudPath, Path]): Path to vector to read. In case of archive, path to the archive.
        crs: Wanted CRS of the vector. If None, using naive or origin CRS.
        archive_regex (str): [Archive only] Regex for the wanted vector inside the archive

    Returns:
        gpd.GeoDataFrame: Read vector as a GeoDataFrame
    &#34;&#34;&#34;
    tmp_dir = None
    arch_vect_path = None
    try:
        path = AnyPath(path)

        # Load vector in cache if needed (geopandas do not use correctly S3 paths for now)
        if isinstance(path, CloudPath):
            tmp_dir = tempfile.TemporaryDirectory()
            if path.suffix == &#34;.shp&#34;:
                # Download everything to disk
                for shp_file in path.parent.glob(path.with_suffix(&#34;.*&#34;).name):
                    cached_path = shp_file.download_to(tmp_dir.name)
                    if cached_path.suffix == &#34;.shp&#34;:
                        path = cached_path
            else:
                path = AnyPath(path.fspath)

        # Manage archive case
        if path.suffix in [&#34;.tar&#34;, &#34;.zip&#34;]:
            prefix = path.suffix[-3:]
            file_list = files.get_archived_file_list(path)

            try:
                regex = re.compile(archive_regex)
                arch_vect_path = list(filter(regex.match, file_list))[0]

                if isinstance(path, CloudPath):
                    vect_path = f&#34;{prefix}+{path}!{arch_vect_path}&#34;
                else:
                    vect_path = f&#34;{prefix}://{path}!{arch_vect_path}&#34;
            except IndexError:
                raise FileNotFoundError(
                    f&#34;Impossible to find vector {archive_regex} in {files.get_filename(path)}&#34;
                )
        elif path.suffixes == [&#34;.tar&#34;, &#34;.gz&#34;]:
            raise TypeError(
                &#34;.tar.gz files are too slow to read from inside the archive. Please extract them instead.&#34;
            )
        else:
            vect_path = str(path)
    except AnyPathTypeError:
        vect_path = str(path)

    # Open vector
    try:
        # Discard some weird error concerning a NULL pointer that outputs a ValueError (as we already except it)
        fiona_logger = logging.getLogger(&#34;fiona&#34;)
        fiona_logger.setLevel(logging.CRITICAL)

        # Read mask

        # Manage KML driver
        if vect_path.endswith(&#34;.kml&#34;):
            set_kml_driver()
            vect = gpd.GeoDataFrame()

            # Document tags in KML file are separate layers for GeoPandas.
            # When you try to get the KML content, you actually get the first layer.
            # So you need for loop for iterating over layers.
            # https://gis.stackexchange.com/questions/328525/geopandas-read-file-only-reading-first-part-of-kml/328554
            import fiona

            for layer in fiona.listlayers(vect_path):
                try:
                    vect_layer = gpd.read_file(vect_path, driver=&#34;KML&#34;, layer=layer)
                    if not vect_layer.empty:
                        # KML files are always in WGS84 (and does not contain this information)
                        vect_layer.crs = WGS84
                        vect = vect.append(vect_layer, ignore_index=True)
                except ValueError:
                    pass  # Except Null Layer

            # Workaround for archived KML -&gt; they may be empty
            # Convert KML to GeoJSON
            if vect.empty and shutil.which(&#34;ogr2ogr&#34;):  # Needs ogr2ogr here
                if not tmp_dir:
                    tmp_dir = tempfile.TemporaryDirectory()
                if path.suffix == &#34;.zip&#34;:
                    with zipfile.ZipFile(path, &#34;r&#34;) as zip_ds:
                        vect_path = zip_ds.extract(arch_vect_path, tmp_dir.name)
                elif path.suffix == &#34;.tar&#34;:
                    with tarfile.open(path, &#34;r&#34;) as tar_ds:
                        tar_ds.extract(arch_vect_path, tmp_dir.name)
                        vect_path = os.path.join(tmp_dir.name, arch_vect_path)

                vect_path_gj = os.path.join(
                    tmp_dir.name, os.path.basename(vect_path).replace(&#34;kml&#34;, &#34;geojson&#34;)
                )
                cmd_line = [
                    &#34;ogr2ogr&#34;,
                    &#34;-fieldTypeToString DateTime&#34;,  # Disable warning
                    &#34;-f GeoJSON&#34;,
                    strings.to_cmd_string(vect_path_gj),  # dst
                    strings.to_cmd_string(vect_path),  # src
                ]
                try:
                    misc.run_cli(cmd_line)
                except RuntimeError as ex:
                    raise RuntimeError(
                        f&#34;Something went wrong with ogr2ogr: {ex}&#34;
                    ) from ex

                # Open the geojson
                vect = gpd.read_file(vect_path_gj)
            else:
                vect.crs = WGS84  # Force set CRS to whole vector
        else:
            vect = gpd.read_file(vect_path)

        # Manage naive geometries
        if vect.crs and crs:
            vect = vect.to_crs(crs)

        # Set fiona logger back to what it was
        fiona_logger.setLevel(logging.INFO)
    except (ValueError, UnsupportedGeometryTypeError) as ex:
        # Do not print warning for null layer
        if &#34;Null layer&#34; not in str(ex):
            LOGGER.warning(ex)
        vect = gpd.GeoDataFrame(geometry=[], crs=crs)

    # Clean
    if tmp_dir:
        tmp_dir.cleanup()

    return vect</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="Home" href="/sertit-utils/">
<img src="https://sertit.pages.sertit.unistra.fr/sertit-utils/sertit_utils.png"
alt="logo"
style="width:40%;"/>
</a>
</header>
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sertit" href="index.html">sertit</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="sertit.vectors.corresponding_utm_projection" href="#sertit.vectors.corresponding_utm_projection">corresponding_utm_projection</a></code></li>
<li><code><a title="sertit.vectors.from_polygon_to_bounds" href="#sertit.vectors.from_polygon_to_bounds">from_polygon_to_bounds</a></code></li>
<li><code><a title="sertit.vectors.from_bounds_to_polygon" href="#sertit.vectors.from_bounds_to_polygon">from_bounds_to_polygon</a></code></li>
<li><code><a title="sertit.vectors.get_geodf" href="#sertit.vectors.get_geodf">get_geodf</a></code></li>
<li><code><a title="sertit.vectors.set_kml_driver" href="#sertit.vectors.set_kml_driver">set_kml_driver</a></code></li>
<li><code><a title="sertit.vectors.get_aoi_wkt" href="#sertit.vectors.get_aoi_wkt">get_aoi_wkt</a></code></li>
<li><code><a title="sertit.vectors.get_wider_exterior" href="#sertit.vectors.get_wider_exterior">get_wider_exterior</a></code></li>
<li><code><a title="sertit.vectors.shapes_to_gdf" href="#sertit.vectors.shapes_to_gdf">shapes_to_gdf</a></code></li>
<li><code><a title="sertit.vectors.read" href="#sertit.vectors.read">read</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>