import pathlib
from typing import Dict

import jinja2
import textwrap3

from cloudspec import CloudSpec
from cloudspec import CloudSpecParam

MODULE_DOC = '''"""
Autogenerated state module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__

{{ plugin.doc }}
"""

'''

IMPORTS = """
{{plugin.imports|join('\n')}}
"""
VIRTUAL_IMPORTS = """
try:
    {{plugin.virtual_imports|join('\n'}}
    HAS_LIBS = True,
except ImportError as e:
    HAS_LIBS = False, str(e)

def __virtual__(hub):
    return HAS_LIBS
"""

VIRTUAL_NAME = """
__virtualname__ = "{{plugin.virtualname}}"
"""

SUB_ALIAS = """
__sub_alias__ = {{plugin.sub_alias}}
"""

PRESENT_FUNCTION = """
async def {{function.name}}(hub, ctx{{function.header_params}})  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    {{function.doc|replace("'" * 3, '"' * 3)}}
    Examples:

        .. code-block:: sls

            resource_is_{{function.name}}:
              {{ function.ref }}.{{ function.name }}:
                - {{ function.required_call_params.split(", ")|join("\n                - ")|replace("=", ": ") }}
    '''
"""

ABSENT_FUNCTION = """
async def {{function.name}}(hub, ctx{{function.header_params}})  -> Dict[str, Any]:
    r'''
    **Autogenerated function**
    {{function.doc|replace("'" * 3, '"' * 3)}}
    Examples:

        .. code-block:: sls

            resource_is_{{function.name}}:
              {{ function.ref }}.{{ function.name }}:
                - {{ function.required_call_params.split(", ")|join("\n                - ")|replace("=", ": ") }}
    '''
"""

DESCRIBE_FUNCTION = """
async def {{function.name}}(hub, ctx)  -> Dict[str, Dict[str, Any]]:
    r'''
    **Autogenerated function**

    Describe the resource in a way that can be recreated/managed with the corresponding "present" function

    {{function.doc|replace("'" * 3, '"' * 3)}}
    Examples:

        .. code-block:: bash

            $ idem describe {{ function.ref }}
    '''
"""


def run(hub, ctx, root_directory: pathlib.Path or str):
    if isinstance(root_directory, str):
        root_directory = pathlib.Path(root_directory)
    cloud_spec = CloudSpec(**ctx.cloud_spec)
    states_dir = root_directory / ctx.clean_name / "states" / ctx.service_name
    for ref, plugin in cloud_spec.plugins.items():
        split = ref.split(".")
        subs = split[:-1]
        mod = split[-1]
        ref = ".".join([ctx.service_name] + subs + [mod])
        state_ref = ".".join([ctx.service_name] + subs + [plugin.virtualname or mod])
        mod_file = states_dir
        for sub in subs:
            mod_file = mod_file / sub
        mod_file = mod_file / f"{mod}.py"
        hub.tool.path.touch(mod_file)

        template_string = MODULE_DOC + "\n"
        if plugin.imports:
            template_string += IMPORTS + "\n"
        if plugin.virtual_imports:
            template_string += VIRTUAL_IMPORTS + "\n"
        if plugin.virtualname:
            template_string += VIRTUAL_NAME + "\n"
        if plugin.sub_alias:
            template_string += SUB_ALIAS + "\n"
        # noinspection JinjaAutoinspect
        pre_template: jinja2.Template = jinja2.Environment(
            autoescape=False
        ).from_string(template_string)
        to_write = pre_template.render(plugin=plugin)

        # Create the present, absent, and describe functions; these are required for every state module
        for function_name, TEMPLATE in zip(
            ("present", "absent", "describe"),
            (PRESENT_FUNCTION, ABSENT_FUNCTION, DESCRIBE_FUNCTION),
        ):
            template: jinja2.Template = jinja2.Environment(
                autoescape=False
            ).from_string(
                f"{TEMPLATE}\n    {cloud_spec.request_format[function_name]}\n\n\n"
            )
            try:
                function_data = plugin.functions[function_name]
            except KeyError as e:
                hub.log.error(f"No '{function_name}' function defined for module {ref}")
                continue

            # noinspection JinjaAutoinspect
            if function_data.doc:
                doc = function_data.doc.replace('"""', "'''")
                doc = "\n" + textwrap3.indent(doc, "    ") + "\n"
            else:
                doc = ""

            if function_name != "describe":
                doc += _get_param_sphinx_docs(function_data.params)

            doc += _get_func_return_sphinx_doc(function_data)
            to_write += template.render(
                function=dict(
                    name=function_name,
                    hardcoded=function_data.hardcoded,
                    doc=doc,
                    ref=ref,
                    state_ref=f"states.{state_ref}",
                    header_params=_get_header_params(function_data.params),
                    required_call_params=_get_call_params(function_data.params),
                ),
                parameter=dict(mapping=_get_map_params(function_data.params)),
            )

            mod_file.write_text(to_write)


def _get_func_return_sphinx_doc(func_data):
    ret = ""
    ret += "\n\n    Returns:\n"
    ret += "        Dict[str, Any]\n"
    return ret


def _get_param_sphinx_docs(parameters: CloudSpecParam) -> str:
    if not parameters:
        return ""

    ret = "\n    Args:\n"
    for param in parameters.values():
        ret += f"        {param.snaked}"
        if param.param_type:
            ret += f"({param.param_type}{', optional' if not param.required else ''})"

        ret += f": {param.doc}"
        if not ret.endswith("."):
            ret += "."
        if not param.required:
            ret += f" Defaults to {param.default}."
        ret += "\n"

    return ret.rstrip()


def _get_header_params(parameters: CloudSpecParam) -> str:
    ret = ""

    required_params = {
        name: data for name, data in parameters.items() if data["required"]
    }
    for param_name, param_data in required_params.items():
        if param_data.get("param_type"):
            ret += f", {param_data.snaked}: {param_data['param_type']}"
        else:
            ret += f", {param_data.snaked}"

    unrequired_params = {
        name: data for name, data in parameters.items() if not data["required"]
    }

    for param_name, param_data in unrequired_params.items():
        param_type = param_data.get("param_type")
        if param_type:
            ret += f", {param_data.snaked}: {param_type}"
        else:
            ret += f", {param_data.snaked}"
        ret += f" = {param_data.default}"

    return ret


def _get_call_params(parameters: CloudSpecParam) -> str:
    ret = []

    required_params = {
        name: data for name, data in parameters.items() if data["required"]
    }
    for param_data in required_params.values():
        ret.append(f"{param_data.snaked}={param_data.default or 'value'}")

    return ", ".join(ret)


def _get_map_params(parameters: CloudSpecParam) -> Dict[str, str]:
    ret = {}
    map_params = {
        name: data
        for name, data in parameters.items()
        if data["target_type"] == "mapping"
    }
    for name, data in map_params.items():
        target = data["target"]
        if target not in ret:
            ret[target] = {}
        ret[target][name] = data.snaked

    fmt = lambda item: ", ".join(f'"{k}": {v}' for k, v in item.items())
    return {k: f"{{{fmt(v)}}}" for k, v in ret.items()}
