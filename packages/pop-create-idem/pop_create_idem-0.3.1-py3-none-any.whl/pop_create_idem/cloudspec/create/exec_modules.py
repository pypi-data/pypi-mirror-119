import pathlib
from typing import Dict

import jinja2
import textwrap3

from cloudspec import CloudSpec
from cloudspec import CloudSpecParam

MODULE_DOC = '''"""
Autogenerated module using `pop-create-idem <https://gitlab.com/saltstack/pop/pop-create-idem>`__
"""

'''

IMPORTS = """
{{plugin.imports|join('\n')}}
"""

VIRTUAL_IMPORTS = """
try:
    {{plugin.virtual_imports|join('\n'}}
    HAS_LIBS = True,
except ImportError as e:
    HAS_LIBS = False, str(e)

def __virtual__(hub):
    return HAS_LIBS
"""

VIRTUAL_NAME = """
__virtualname__ = "{{plugin.virtualname}}"
"""

SUB_ALIAS = """
__sub_alias__ = {{plugin.sub_alias}}
"""

FUNC_ALIAS = """
__func_alias__ = {{plugin.func_alias}}
"""

EXEC_MODULE = """
async def {{function.name}}(hub, ctx{{function.header_params}}) -> {{function.return_type}}:
    r'''
    **Autogenerated function**
    {{function.doc|replace("'" * 3, '"' * 3)}}
    Examples:
        Call from code:

        .. code-block:: python

            await hub.exec.{{function.ref}}(ctx{{ ", " if function.required_call_params else "" }}{{function.required_call_params}})

        Call from CLI:

        .. code-block:: bash

            $ idem exec {{function.cli_ref}} {{function.required_call_params}}
    '''
""".strip()


def run(hub, ctx, root_directory: pathlib.Path or str):
    if isinstance(root_directory, str):
        root_directory = pathlib.Path(root_directory)
    cloud_spec = CloudSpec(**ctx.cloud_spec)
    exec_dir = (
        root_directory
        / ctx.clean_name
        / "exec"
        / ctx.service_name
        / ctx.clean_api_version
    )
    for ref, plugin in cloud_spec.plugins.items():
        split = ref.split(".")
        subs = split[:-1]
        mod = split[-1]
        ref = ".".join([ctx.service_name] + subs + [mod])
        cli_ref = ".".join([ctx.service_name] + subs + [plugin.virtualname or mod])
        mod_file = exec_dir
        for sub in subs:
            mod_file = mod_file / sub
        mod_file = mod_file / f"{mod}.py"
        hub.tool.path.touch(mod_file)

        template_string = MODULE_DOC + "\n"
        if plugin.imports:
            template_string += IMPORTS + "\n"
        if plugin.virtual_imports:
            template_string += VIRTUAL_IMPORTS + "\n"
        if plugin.virtualname:
            template_string += VIRTUAL_NAME + "\n"
        if plugin.sub_alias:
            template_string += SUB_ALIAS + "\n"
        if plugin.func_alias:
            template_string += FUNC_ALIAS + "\n"
        # noinspection JinjaAutoinspect
        pre_template: jinja2.Template = jinja2.Environment(
            autoescape=False
        ).from_string(template_string)
        to_write = pre_template.render(plugin=plugin)
        for function_name, function_data in plugin.functions.items():
            # noinspection JinjaAutoinspect
            template: jinja2.Template = jinja2.Environment(
                autoescape=False
            ).from_string(f"{EXEC_MODULE}\n    {cloud_spec.request_format}\n\n\n")
            if function_data.doc:
                doc = function_data.doc.replace('"""', "'''")
                doc = "\n" + textwrap3.indent(doc, "    ") + "\n"
            else:
                doc = ""

            function_alias = plugin.func_alias.get(function_name, function_name)

            to_write += template.render(
                function=dict(
                    name=function_name,
                    hardcoded=function_data.hardcoded,
                    doc=doc
                    + _get_param_sphinx_docs(function_data.params)
                    + _get_func_return_sphinx_doc(function_data),
                    ref=f"{ref}.{function_alias}",
                    cli_ref=f"{cli_ref}.{function_alias}",
                    header_params=_get_header_params(function_data.params),
                    required_call_params=_get_call_params(function_data.params),
                    return_type=function_data.return_type,
                ),
                parameter=dict(mapping=_get_map_params(function_data.params)),
            )

        mod_file.write_text(to_write)


def _get_func_return_sphinx_doc(func_data):
    ret = ""
    if func_data.return_type:
        ret += "\n\n    Returns:\n"
        ret += f"        {func_data.return_type}"
        ret += "\n"
    return ret


def _get_param_sphinx_docs(parameters: CloudSpecParam) -> str:
    if not parameters:
        return ""

    ret = "\n    Args:\n"
    for param in parameters.values():
        ret += f"        {param.snaked}"
        if param.param_type:
            ret += f"({param.param_type}{', optional' if not param.required else ''})"

        ret += f": {param.doc}"
        if not ret.endswith("."):
            ret += "."
        if not param.required:
            ret += f" Defaults to {param.default}."
        ret += "\n"

    return ret.rstrip()


def _get_header_params(parameters: CloudSpecParam) -> str:
    ret = ""

    required_params = {
        name: data for name, data in parameters.items() if data["required"]
    }
    for param_name, param_data in required_params.items():
        if param_data.get("param_type"):
            ret += f", {param_data.snaked}: {param_data['param_type']}"
        else:
            ret += f", {param_data.snaked}"

    unrequired_params = {
        name: data for name, data in parameters.items() if not data["required"]
    }

    for param_name, param_data in unrequired_params.items():
        param_type = param_data.get("param_type")
        if param_type:
            ret += f", {param_data.snaked}: {param_type}"
        else:
            ret += f", {param_data.snaked}"
        ret += f" = {param_data.default}"

    return ret


def _get_call_params(parameters: CloudSpecParam) -> str:
    ret = []

    required_params = {
        name: data for name, data in parameters.items() if data["required"]
    }
    for param_data in required_params.values():
        ret.append(f"{param_data.snaked}={param_data.default or 'value'}")

    return ", ".join(ret)


def _get_map_params(parameters: CloudSpecParam) -> Dict[str, str]:
    ret = {}
    map_params = {
        name: data
        for name, data in parameters.items()
        if data["target_type"] == "mapping"
    }
    for name, data in map_params.items():
        target = data["target"]
        if target not in ret:
            ret[target] = {}
        ret[target][name] = data.snaked

    fmt = lambda item: ", ".join(f'"{k}": {v}' for k, v in item.items())
    return {k: f"{{{fmt(v)}}}" for k, v in ret.items()}
