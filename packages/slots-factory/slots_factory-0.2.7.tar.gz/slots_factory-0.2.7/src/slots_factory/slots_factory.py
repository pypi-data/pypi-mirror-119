import itertools
from types import new_class, FunctionType


from slots_factory.tools.SlotsFactoryTools import (
    _slots_factory_hash,
    _slots_factory_setattrs,
    _slots_factory_setattrs_slim,
    _slots_factory_setattrs_from_object,
)


from .object_model_methods import (
    _frozen,
    _ordering_methods,
    __repr__,
    __len__,
    __eq__,
    __hash__,
    __iter__,
)


TYPEDEF_DICT_KEYS = {
    "__module__",
    "__annotations__",
    "__doc__",
    "__dict__",
    "__weakref__",
}


def slots_from_type(type_, **kwargs):
    """Convenience function. Takes a type and kwargs, and instantiates the type
    with kwargs assigned to corresponding attributes.

    :param type_: type as derived from type_factory()
    :type type_: type
    :return: instance of the type, with assigned attributes
    :rtype: SlotsObject
    """
    instance = type_()
    _slots_factory_setattrs_slim(instance, kwargs, False)
    return instance


def slots_from_dict(attrs={}, _name="SlotsObject", **kwargs):
    """function that returns a Python Python instance w/ __slots__ from a dict,
    allows for same kwargs as dataslots.
    
    :param attrs: dictionary template for setting attr values on returned
    instance
    :param _name: name of returned object
    :param **kwargs: options for type definition, mirrors those of @dataslots

    :return: SlotsObject instance
    :rtype: SlotsObject
    """
    if not kwargs.get("order"):
        kwargs["order"] = attrs.keys()
    type_ = fast_slots.__dict__.get(_name)
    if not type_:
        fast_slots.__dict__[_name] = type_factory(attrs.keys(), _name, **kwargs)
    return fast_slots(_name, **attrs)


def type_factory(args, _name="Slots_Object", _bases=(), _metaclass=type, **kwargs):
    """function that returns a new Python type w/ __slots__, and other dunder
    methods if specified.

    :param _name: name of the new type
    :type _name: str
    :param args: iterable (list, tuple) of strings that correspond to the
    attributes of the objects
    :type args: Iter[str, str...]

    :return: type definition defined by function arguments
    :rtype: type
    """

    methods = {
        "__slots__": args,
        "__iter__": __iter__,
        "__len__": __len__,
        "__eq__": __eq__,
        "__hash__": __hash__,
        "__repr__": __repr__,
    }

    frozen = kwargs.get("frozen")
    if frozen:
        methods["__setattr__"] = _frozen
        methods["__delattr__"] = _frozen

    _order = kwargs.get("order")
    if _order:
        methods.update(
            _ordering_methods(args, _order)
        )

    _methods = kwargs.get("_methods")
    if _methods:
        methods.update(**_methods)

    return new_class(
        _name,
        _bases,
        kwds={"metaclass": _metaclass},
        exec_body=lambda ns: ns.update(methods),
    )


def slots_factory(_name="SlotsObject", **kwargs):
    """Factory function for creating python objects with __slots__.

    :param _name: type name to tag to type definition, defaults to "SlotsObject"
    :type _name: str, optional
    :param **kwargs: key=value pairs of attribute values to be applied to the
    instance generated by the factory function

    :return: returns an instance of the type built for the python object
    :rtype: SlotsObject
    """
    id_ = _slots_factory_hash(_name, kwargs)
    type_ = slots_factory.__dict__.get(id_)
    if not type_:
        type_ = type_factory(kwargs.keys(), _name, order=kwargs.keys())
        slots_factory.__dict__[id_] = type_
    instance = type_()
    _slots_factory_setattrs_slim(instance, kwargs, False)
    return instance


def fast_slots(_name="SlotsObject", **kwargs):
    """Factory function for creating python objects with __slots__. Only uses
    name for caching, and makes a new object type when AttributeError is raised.

    :param _name: type name to tag to type definition, defaults to "SlotsObject"
    :type _name: str, optional
    :param **kwargs: key=value pairs of attribute values to be applied to the
    instance generated by the factory function

    :return: returns an instance of the type built for the python object
    :rtype: SlotsObject
    """
    type_ = fast_slots.__dict__.get(_name)
    if not type_:
        type_ = type_factory(kwargs.keys(), _name, order=kwargs.keys())
        fast_slots.__dict__[_name] = type_
    try:
        instance = type_()
        _slots_factory_setattrs_slim(instance, kwargs, True)
        return instance
    except AttributeError:
        del fast_slots.__dict__[_name]
        return fast_slots(_name, **kwargs)


def dataslots(_cls=None, **ds_kwargs):
    """provides a decorator for ingesting type definitions derived from `class`
    and returning a retyped definition which contains __slots__.

    :param _cls: object to be emulated
    :type _cls: type

    :param frozen: optional flag for ensuring data is immutable
    :type frozen: bool

    :return: wrapper functions
    :rtype: function
    """

    def wrapper(f):
        """wrapper called to generate the type at runtime"""
        _attrs, _methods, _callables, _dependents = {}, {}, {}, {}

        _seen_keys = set()
        for (attr, collection) in (
            (attr, getattr(f, attr))
            for attr in ("__dict__", "__annotations__")
            if hasattr(f, attr)
        ):
            for k, v in collection.items():
                if k in TYPEDEF_DICT_KEYS or k in _seen_keys:
                    continue
                if isinstance(v, type) and attr == "__dict__":
                    _callables[k] = v
                elif isinstance(v, FunctionType):
                    if v.__name__ == "<lambda>":
                        if v.__code__.co_argcount == 1:
                            _dependents[k] = v
                        elif v.__code__.co_argcount == 0:
                            _callables[k] = v
                        else:
                            raise SyntaxError(
                                "lambda-type factory functions"
                                " must take either 'self' as an argument,"
                                " or take no arguments"
                            )
                    else:
                        _methods[k] = v
                elif isinstance(v, property):
                    _methods[k] = v
                else:
                    _attrs[k] = v
                _seen_keys.add(k)

        _defaults = {key: getattr(f, key) for key in _attrs.keys() if hasattr(f, key)}

        if not getattr(wrapper, "ds_kwargs", False):
            if not (_defaults or _callables or _dependents):
                def __init__(self, **kwargs):
                    """slim"""
                    _slots_factory_setattrs_slim(self, kwargs, False)
            else:
                def __init__(self, **kwargs):
                    """generic"""
                    _slots_factory_setattrs(
                        self, _callables, _defaults, kwargs, _dependents, False
                    )
        else:
            def __init__(self, **kwargs):
                """frozen"""
                _slots_factory_setattrs_from_object(
                    object, self, _callables, _defaults, kwargs, _dependents
                )


        _ds_kwargs = {
            "_methods": {
                "__init__": __init__, 
                "__doc__": f.__doc__,
                **_methods
            },
            **wrapper.__dict__["ds_kwargs"],
        }

        _type = type_factory(
            args=list(itertools.chain(
                _attrs.keys(), _callables.keys(), _dependents.keys()
            )),
            _name=f.__name__,
            _bases=(),
            _metaclass=DSMeta,
            **_ds_kwargs
        )

        __init__.__dict__["_defaults"] = _defaults
        __init__.__dict__["_callables"] = _callables
        __init__.__dict__["_methods"] = _methods
        __init__.__dict__["_dependents"] = _dependents

        return _type

    wrapper.__dict__["ds_kwargs"] = ds_kwargs

    if _cls is None:
        return wrapper
    return wrapper(_cls)

dataslots.__dict__["from_dict"] = slots_from_dict


class DSMeta(type):
    """handles 'inheritance' (by stealing, not inheriting)"""
    def __new__(cls, name, bases, body):
        for base in reversed(bases):
            try:
                result = {}
                for item in base.__slots__:
                    result[item] = getattr(base, item)
                for _, v in base.__init__.__dict__.items():
                    result.update(v)
                body.update(result)
            except AttributeError:
                pass

        return super().__new__(cls, name, (), body)
