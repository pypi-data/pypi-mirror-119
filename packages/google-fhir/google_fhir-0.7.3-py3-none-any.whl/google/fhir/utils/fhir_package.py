#
# Copyright 2021 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""Utility class for abstracting over FHIR definitions."""

import re
from typing import cast, Any, Dict, List, Optional, Tuple
import zipfile

import logging

from google.protobuf import text_format

from proto.google.fhir.proto import annotations_pb2
from proto.google.fhir.proto import profile_config_pb2
from proto.google.fhir.proto.r4.core.resources import bundle_and_contained_resource_pb2
from proto.google.fhir.proto.r4.core.resources import code_system_pb2
from proto.google.fhir.proto.r4.core.resources import search_parameter_pb2
from proto.google.fhir.proto.r4.core.resources import structure_definition_pb2
from proto.google.fhir.proto.r4.core.resources import value_set_pb2
from google.fhir.r4 import json_format
from google.fhir.utils import proto_utils
from google.fhir.utils import resource_utils

# TODO: Currently only supports R4. Make FHIR-version agnostic.

_RESOURCE_TYPE_PATTERN = re.compile(r'"resourceType"\s*:\s*"([A-Za-z]*)"')


def _get_resource_type(raw_json: str) -> Optional[str]:
  m = _RESOURCE_TYPE_PATTERN.search(raw_json)
  return m.group(1) if m is not None else None


def _read_fhir_package_zip(
    zip_file_path: str
) -> Tuple[profile_config_pb2.PackageInfo, Dict[str, str]]:
  """Indexes the file entries at `zip_file_path` and returns package info.

  Args:
    zip_file_path: The `.zip` file that should be parsed.

  Returns:
    A tuple of (package info, JSON entries), detailing the package information
    and associated `.json` files indexed by filename, respectively.

  Raises:
    ValueError: In the event that the `PackgeInfo` is invalid.
  """
  package_info: Optional[profile_config_pb2.PackageInfo] = None
  json_files: Dict[str, str] = {}
  with zipfile.ZipFile(zip_file_path, mode='r') as f:
    for entry_name in f.namelist():
      if (entry_name.endswith('package_info.textproto') or
          entry_name.endswith('package_info.prototxt')):
        data = f.read(entry_name)
        package_info: profile_config_pb2.PackageInfo = (
            text_format.Parse(data, profile_config_pb2.PackageInfo()))
        if not package_info.proto_package:
          raise ValueError(
              f'Missing proto_package from PackageInfo in: {zip_file_path}.')
        if package_info.fhir_version != annotations_pb2.R4:
          raise ValueError(
              f'Unsupported FHIR version: {package_info.fhir_version}.')
      elif entry_name.endswith('.json'):
        json_files[entry_name] = f.read(entry_name).decode('utf-8')
      else:
        logging.info('Skipping .zip entry: %s.', entry_name)

  if package_info is None:
    raise ValueError('FhirPackage does not have a valid '
                     f'`package_info.prototext`: {zipfile}.')

  return (package_info, json_files)


class FhirPackage:
  """Represents a FHIR Proto package.

  The FHIR Proto package is constructed from a `.zip` file containing defining
  resources and a `PackageInfo` proto, as generated by the `fhir_package` rule
  in `protogen.bzl`.
  """

  @classmethod
  def load(cls, zip_file_path: str) -> 'FhirPackage':
    """Instantiates and returns a new `FhirPackage` from a `.zip` file.

    Args:
      zip_file_path: A path to the `.zip` file containing the `FhirPackage`
        contents.

    Returns:
      An instance of `FhirPackage`.

    Raises:
      ValueError: In the event that the `PackageInfo` is invalid.
    """
    package_info, json_files = _read_fhir_package_zip(zip_file_path)

    # Populate instance attrs
    structure_definitions: List[
        structure_definition_pb2.StructureDefinition] = []
    search_parameters: List[search_parameter_pb2.SearchParameter] = []
    code_systems: List[code_system_pb2.CodeSystem] = []
    value_sets: List[value_set_pb2.ValueSet] = []

    for file_name, raw_json in json_files.items():
      expected_type = _get_resource_type(raw_json)
      if expected_type is None:
        logging.warning('Unhandled JSON entry: %s.', file_name)
        continue

      if expected_type == 'ValueSet':
        value_set = json_format.json_fhir_string_to_proto(
            raw_json, value_set_pb2.ValueSet)
        value_sets.append(value_set)
      elif expected_type == 'CodeSystem':
        code_system = json_format.json_fhir_string_to_proto(
            raw_json, code_system_pb2.CodeSystem)
        code_systems.append(code_system)
      elif expected_type == 'StructureDefinition':
        structure_definition = json_format.json_fhir_string_to_proto(
            raw_json, structure_definition_pb2.StructureDefinition)
        structure_definitions.append(structure_definition)
      elif expected_type == 'SearchParameter':
        search_parameter = json_format.json_fhir_string_to_proto(
            raw_json, search_parameter_pb2.SearchParameter)
        search_parameters.append(search_parameter)
      elif expected_type == 'Bundle':
        bundle = json_format.json_fhir_string_to_proto(
            raw_json, bundle_and_contained_resource_pb2.Bundle)
        for entry in bundle.entry:
          contained = resource_utils.get_contained_resource(entry.resource)
          if proto_utils.is_message_type(contained, value_set_pb2.ValueSet):
            value_sets.append(cast(value_set_pb2.ValueSet, contained))
          elif proto_utils.is_message_type(contained,
                                           code_system_pb2.CodeSystem):
            code_systems.append(cast(code_system_pb2.CodeSystem, contained))
          elif proto_utils.is_message_type(
              contained, structure_definition_pb2.StructureDefinition):
            structure_definitions.append(
                cast(structure_definition_pb2.StructureDefinition, contained))
          else:
            logging.warning('Unrecognized contained resource type: %s.',
                            type(contained))
      else:
        logging.warning('Unhandled JSON entry: %s.', file_name)

    return FhirPackage(
        package_info=package_info,
        structure_definitions=structure_definitions,
        search_parameters=search_parameters,
        code_systems=code_systems,
        value_sets=value_sets)

  def __init__(self, *, package_info: profile_config_pb2.PackageInfo,
               structure_definitions: List[
                   structure_definition_pb2.StructureDefinition],
               search_parameters: List[search_parameter_pb2.SearchParameter],
               code_systems: List[code_system_pb2.CodeSystem],
               value_sets: List[value_set_pb2.ValueSet]) -> None:
    """Creates a new instance of `FhirPackage`. Callers should favor `load`."""
    self.package_info = package_info
    self.structure_definitions = structure_definitions
    self.search_parameters = search_parameters
    self.code_systems = code_systems
    self.value_sets = value_sets

  def __eq__(self, o: Any) -> bool:
    if not isinstance(o, FhirPackage):
      return False
    return self.package_info.proto_package == o.package_info.proto_package

  def __hash__(self) -> int:
    return hash(self.package_info.proto_package)
