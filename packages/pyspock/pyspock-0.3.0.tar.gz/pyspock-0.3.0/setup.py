# -*- coding: utf-8 -*-
from setuptools import setup

package_dir = \
{'': 'src'}

packages = \
['_spock', 'spock']

package_data = \
{'': ['*']}

install_requires = \
['pytest>=6.2.4,<7.0.0']

entry_points = \
{'pytest11': ['spock = _spock.plugin']}

setup_kwargs = {
    'name': 'pyspock',
    'version': '0.3.0',
    'description': 'Python implementation for spock framework',
    'long_description': '# spock\n\n<div align="center">\n  <a href="https://github.com/zen-xu/spock/actions">\n    <img src="https://github.com/zen-xu/spock/actions/workflows/main.yaml/badge.svg" alt="CI"/>\n  </a>\n  <a href="https://codecov.io/gh/zen-xu/spock">\n    <img src="https://codecov.io/gh/zen-xu/spock/branch/main/graph/badge.svg?token=WPG2V9w16r"/>\n  </a>\n  <a href="https://pypi.org/project/pyspock">\n    <img alt="PyPI" src="https://img.shields.io/pypi/v/pyspock">\n  </a>\n  <img src="https://img.shields.io/pypi/pyversions/pyspock">\n  <a href="https://github.com/zen-xu/spock/blob/main/LICENSE">\n    <img src="https://img.shields.io/badge/MIT%202.0-blue.svg" alt="License">\n  </a>\n</div>\n<div align="center">\n  <a href="https://results.pre-commit.ci/latest/github/zen-xu/spock/main">\n    <img src="https://results.pre-commit.ci/badge/github/zen-xu/spock/propertiesmain.svg">\n  </a>\n  <a href="https://github.com/psf/black">\n    <img src="https://img.shields.io/badge/code%20style-black-000000.svg">\n  </a>\n  <a href="https://deepsource.io/gh/zen-xu/spock/?ref=repository-badge}" target="_blank">\n    <img alt="DeepSource" title="DeepSource" src="https://deepsource.io/gh/zen-xu/spock.svg/?label=active+issues&show_trend=true&token=mgZ7FgiJDAxSt9Ilav9vLFEo"/>\n  </a>\n</div>\n\n`pyspock` is a BDD-style developer testing and specification framework for Python, and this is an implementation of the [`spock`](https://github.com/spockframework/spock).\n\nAn example of simple test:\n\n```python\nimport pytest\n\n\n@pytest.mark.spock("maximum of {a} and {b} is {c}")\ndef test_maximum():\n    def expect(a, b, c):\n        assert max(a, b) == c\n\n    def where(_, a, b, c):\n        _ | a | b | c\n        _ | 3 | 7 | 7\n        _ | 5 | 4 | 5\n        _ | 9 | 9 | 9\n```\n\nIf you are using vscode, you can find there will be 3 test cases.\n\n![vscode-test-discovery](doc/en/img/vscode-testing-discovery.png)\n\n## Installation\n\n```bash\npip install pyspock\n```\n\nNote the minimum version of pytest is 6.2.4.\n\n## Mark\n\nIt is easy to define spock test cases, just use `pytest.mark.spock` to decorate your test function.\n\n```python\n@pytest.mark.spock\ndef test_bigger():\n    def expect():\n        assert 2 > 1\n```\n\nspock mark also accepts one parameter, which is used to render identity for each iteration arguments.\n\n```python\n@pytest.mark.spock("{a} > {b}")\ndef test_bigger():\n    def expect(a, b):\n        assert a > b\n\n    def where(_, a, b):\n        _ | a | b\n        _ | 7 | 3\n        _ | 5 | 2\n```\n\n## Blocks\n\nThere are six kinds of blocks: `given`, `when`, `then`, `expect`, `cleanup` and `where` blocks. Each block is a function defined by its name.\n\nA test function must have at least one explicit block. Blocks divide a test function into distinct sections, and cannot be nested.\n\n![](doc/img/../en/img/Blocks2Phases.png)\n\nThe above picture shows how blocks map to the conceptual phases of a feature function. The where block has a special role, which will be revealed shortly. But first, let’s have a closer look at the other blocks.\n\n\n### 1. Given block\n\n```python\n@pytest.mark.spock\ndef test_demo():\n    def given(me):\n        me.stack = []\n        me.elem = 1\n```\n\nThe `given` block is where you do any setup work for the feature that you are describing. It may not be preceded by other blocks. A `given` block doesn’t have any special semantic, and it is optional and may be omitted.\n\nThe `given` accepts all pytest fixtures, besides it has a special fixture named `me`, which can take any setup values. Those setup values can be as fixtures in other blocks except the `where` block.\n\n### 2. When and Then blocks\n\n```python\n@pytest.mark.spock\ndef test_append_element():\n    def given(me):\n        me.stack = []\n        me.elem = 1\n\n    def when(stack, elem):\n        # stimulus\n        stack.append(elem)\n\n    def then(stack, elem):\n        # response\n        assert len(stack) == 1\n        assert stack.pop() == elem\n```\n\nThe `when` and `then` blocks always occur together. They describe a stimulus and the expected response. Whereas when blocks may contain arbitrary code, then blocks are restricted to conditions, exception conditions, interactions.\n\nThe `then` has a special fixture named `excinfo`, which represents whether the `when` block raises exception. If the `when` block not raises exception, then `excinfo` will be None. The `excinfo` type is [ExceptionInfo](https://docs.pytest.org/en/stable/reference.html#exceptioninfo).\n\n\n```python\n@pytest.mark.spock\ndef test_zero_division():\n    def when():\n        1 / 0\n\n    def then(excinfo):\n        assert excinfo.type is ZeroDivisionError\n```\n\n### 3. Expect block\n\nAn `expect` block is more limited than a `then` block in that it may only contain conditions and variable definitions. It is useful in situations where it is more natural to describe stimulus and expected response in a single expression. For example, compare the following two attempts to describe the `max` function:\n\n```python\n@pytest.mark.spock\ndef test_maximum():\n    def given(me):\n        me.x = max(1, 2)\n\n    def then(x):\n        assert x == 2\n```\n\nequals to:\n\n```python\n@pytest.mark.spock\ndef test_maximum():\n    def expect():\n        assert max(1, 2) == 2\n```\n\n### 4. Cleanup block\n\n```python\n@pytest.mark.spock\ndef test_file():\n    def given(me):\n        me.file = open("test.txt", "r+")\n\n    def when(file):\n        file.write("hello")\n\n    def then(file):\n        file.seek(0)\n        assert file.read() == "hello"\n\n    def cleanup(file):\n        file.close()\n```\n\n `cleanup` block is used to free any resources used by a test case, and will run even if (a previous part of) the test case has produced an exception. As a consequence, a `cleanup` block must be coded defensively.\n\n### 5. Where block\n\nA `where` block always comes last in a test function. It is used to write data-driven feature functions. To give you an idea how this is done, have a look at the following example:\n\n```python\n@pytest.mark.spock("max({a}, {b}) == {c}")\ndef test_maximum_of_two_numbers():\n    def expect(a, b, c):\n        assert max(a, b) == c\n\n    def where(a, b, c):\n        a << [5, 3]\n        b << [1, 9]\n        c << [5, 9]\n```\n\nThis `where` block effectively creates two "versions" of the feature functions: One where a is 5, b is 1, and c is 5, and another one where a is 3, b is 9, and c is 9.\n\nAlthough it is declared last, the where block is evaluated before the feature function containing it runs.\n\n#### Data table\n\n`where` block support another syntax to specify the data.\n\n```python\n@pytest.mark.spock("max({a}, {b}) == {c}")\ndef test_maximum_of_two_numbers():\n    def expect(a, b, c):\n        assert max(a, b) == c\n\n    def where(_, a, b, c):\n        _ | a | b | c\n        _ | 5 | 1 | 5\n        _ | 3 | 9 | 9\n```\n\nThe first line of the table, called the table header, declares the data variables. The subsequent lines, called table rows, hold the corresponding values. For each row, the feature method will get executed once; we call this an iteration of the function. If an iteration fails, the remaining iterations will nevertheless be executed. All failures will be reported.\n\nYou can also split the data table into multiple parts.\n\n```python\n@pytest.mark.spock("max({a}, {b}) == {c}")\ndef test_maximum_of_two_numbers():\n    def expect(a, b, c):\n        assert max(a, b) == c\n\n    def where(_, a, b, c):\n        _ | a | b\n        _ | 5 | 1\n        _ | 3 | 9\n\n        _ | c\n        _ | 5\n        _ | 9\n```\n\n#### Accessing other data variables\n\n```python\ndef where(_, a, b):\n    _ | a | b\n    _ | 5 | a + 1\n    _ | 3 | a + 2\n```\n\nvariable supports all operators like `+`, `-`, `*`, `/`, `%`, `**`, `//`, `==`, `!=`, `<`, `<=`, `>`, `>=` and so on.\n\n#### adapter black\n\nif you are using `black`, you should close fmt when use data table.\n\n```python\ndef where(_, a, b, c):\n    # fmt: off\n    _ | a | b     | c\n    _ | 5 | a + 1 | 4\n    _ | 3 | a + 2 | 2\n    # fmt: on\n```\n\n### 6. Conclusion\n\n| block       | Support fixtures | Special fixtures | Optional                   |\n| ----------- | ---------------- | ---------------- | -------------------------- |\n| **given**   | ✅                | `me`             | ✅                          |\n| **when**    | ✅                | ❎                | ✅                          |\n| **then**    | ✅                | `excinfo`        | when `expect` block exists |\n| **expect**  | ❎                | ❎                | when `then` block exists   |\n| **cleanup** | ✅                | ❎                | ✅                          |\n| **where**   | ✅                | `_`              | ✅                          |\n',
    'author': 'ZhengYu, Xu',
    'author_email': 'zen-xu@outlook.com',
    'maintainer': None,
    'maintainer_email': None,
    'url': None,
    'package_dir': package_dir,
    'packages': packages,
    'package_data': package_data,
    'install_requires': install_requires,
    'entry_points': entry_points,
    'python_requires': '>=3.7,<4.0',
}


setup(**setup_kwargs)
