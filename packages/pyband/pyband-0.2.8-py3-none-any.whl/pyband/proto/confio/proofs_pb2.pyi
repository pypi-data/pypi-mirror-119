"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file
"""
import builtins
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import typing
import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor = ...

class HashOp(_HashOp, metaclass=_HashOpEnumTypeWrapper):
    pass
class _HashOp:
    V = typing.NewType('V', builtins.int)
class _HashOpEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_HashOp.V], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
    # NO_HASH is the default if no data passed. Note this is an illegal argument some places.
    NO_HASH = HashOp.V(0)
    SHA256 = HashOp.V(1)
    SHA512 = HashOp.V(2)
    KECCAK = HashOp.V(3)
    RIPEMD160 = HashOp.V(4)
    # ripemd160(sha256(x))
    BITCOIN = HashOp.V(5)

# NO_HASH is the default if no data passed. Note this is an illegal argument some places.
NO_HASH = HashOp.V(0)
SHA256 = HashOp.V(1)
SHA512 = HashOp.V(2)
KECCAK = HashOp.V(3)
RIPEMD160 = HashOp.V(4)
# ripemd160(sha256(x))
BITCOIN = HashOp.V(5)
global___HashOp = HashOp


#*
#LengthOp defines how to process the key and value of the LeafOp
#to include length information. After encoding the length with the given
#algorithm, the length will be prepended to the key and value bytes.
#(Each one with it's own encoded length)
class LengthOp(_LengthOp, metaclass=_LengthOpEnumTypeWrapper):
    pass
class _LengthOp:
    V = typing.NewType('V', builtins.int)
class _LengthOpEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_LengthOp.V], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor = ...
    # NO_PREFIX don't include any length info
    NO_PREFIX = LengthOp.V(0)
    # VAR_PROTO uses protobuf (and go-amino) varint encoding of the length
    VAR_PROTO = LengthOp.V(1)
    # VAR_RLP uses rlp int encoding of the length
    VAR_RLP = LengthOp.V(2)
    # FIXED32_BIG uses big-endian encoding of the length as a 32 bit integer
    FIXED32_BIG = LengthOp.V(3)
    # FIXED32_LITTLE uses little-endian encoding of the length as a 32 bit integer
    FIXED32_LITTLE = LengthOp.V(4)
    # FIXED64_BIG uses big-endian encoding of the length as a 64 bit integer
    FIXED64_BIG = LengthOp.V(5)
    # FIXED64_LITTLE uses little-endian encoding of the length as a 64 bit integer
    FIXED64_LITTLE = LengthOp.V(6)
    # REQUIRE_32_BYTES is like NONE, but will fail if the input is not exactly 32 bytes (sha256 output)
    REQUIRE_32_BYTES = LengthOp.V(7)
    # REQUIRE_64_BYTES is like NONE, but will fail if the input is not exactly 64 bytes (sha512 output)
    REQUIRE_64_BYTES = LengthOp.V(8)

# NO_PREFIX don't include any length info
NO_PREFIX = LengthOp.V(0)
# VAR_PROTO uses protobuf (and go-amino) varint encoding of the length
VAR_PROTO = LengthOp.V(1)
# VAR_RLP uses rlp int encoding of the length
VAR_RLP = LengthOp.V(2)
# FIXED32_BIG uses big-endian encoding of the length as a 32 bit integer
FIXED32_BIG = LengthOp.V(3)
# FIXED32_LITTLE uses little-endian encoding of the length as a 32 bit integer
FIXED32_LITTLE = LengthOp.V(4)
# FIXED64_BIG uses big-endian encoding of the length as a 64 bit integer
FIXED64_BIG = LengthOp.V(5)
# FIXED64_LITTLE uses little-endian encoding of the length as a 64 bit integer
FIXED64_LITTLE = LengthOp.V(6)
# REQUIRE_32_BYTES is like NONE, but will fail if the input is not exactly 32 bytes (sha256 output)
REQUIRE_32_BYTES = LengthOp.V(7)
# REQUIRE_64_BYTES is like NONE, but will fail if the input is not exactly 64 bytes (sha512 output)
REQUIRE_64_BYTES = LengthOp.V(8)
global___LengthOp = LengthOp


#*
#ExistenceProof takes a key and a value and a set of steps to perform on it.
#The result of peforming all these steps will provide a "root hash", which can
#be compared to the value in a header.
#
#Since it is computationally infeasible to produce a hash collission for any of the used
#cryptographic hash functions, if someone can provide a series of operations to transform
#a given key and value into a root hash that matches some trusted root, these key and values
#must be in the referenced merkle tree.
#
#The only possible issue is maliablity in LeafOp, such as providing extra prefix data,
#which should be controlled by a spec. Eg. with lengthOp as NONE,
#prefix = FOO, key = BAR, value = CHOICE
#and
#prefix = F, key = OOBAR, value = CHOICE
#would produce the same value.
#
#With LengthOp this is tricker but not impossible. Which is why the "leafPrefixEqual" field
#in the ProofSpec is valuable to prevent this mutability. And why all trees should
#length-prefix the data before hashing it.
class ExistenceProof(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    KEY_FIELD_NUMBER: builtins.int
    VALUE_FIELD_NUMBER: builtins.int
    LEAF_FIELD_NUMBER: builtins.int
    PATH_FIELD_NUMBER: builtins.int
    key: builtins.bytes = ...
    value: builtins.bytes = ...
    @property
    def leaf(self) -> global___LeafOp: ...
    @property
    def path(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___InnerOp]: ...
    def __init__(self,
        *,
        key : builtins.bytes = ...,
        value : builtins.bytes = ...,
        leaf : typing.Optional[global___LeafOp] = ...,
        path : typing.Optional[typing.Iterable[global___InnerOp]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"leaf",b"leaf"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"key",b"key",u"leaf",b"leaf",u"path",b"path",u"value",b"value"]) -> None: ...
global___ExistenceProof = ExistenceProof

#
#NonExistenceProof takes a proof of two neighbors, one left of the desired key,
#one right of the desired key. If both proofs are valid AND they are neighbors,
#then there is no valid proof for the given key.
class NonExistenceProof(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    KEY_FIELD_NUMBER: builtins.int
    LEFT_FIELD_NUMBER: builtins.int
    RIGHT_FIELD_NUMBER: builtins.int
    # TODO: remove this as unnecessary??? we prove a range
    key: builtins.bytes = ...
    @property
    def left(self) -> global___ExistenceProof: ...
    @property
    def right(self) -> global___ExistenceProof: ...
    def __init__(self,
        *,
        key : builtins.bytes = ...,
        left : typing.Optional[global___ExistenceProof] = ...,
        right : typing.Optional[global___ExistenceProof] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"left",b"left",u"right",b"right"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"key",b"key",u"left",b"left",u"right",b"right"]) -> None: ...
global___NonExistenceProof = NonExistenceProof

#
#CommitmentProof is either an ExistenceProof or a NonExistenceProof, or a Batch of such messages
class CommitmentProof(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    EXIST_FIELD_NUMBER: builtins.int
    NONEXIST_FIELD_NUMBER: builtins.int
    BATCH_FIELD_NUMBER: builtins.int
    COMPRESSED_FIELD_NUMBER: builtins.int
    @property
    def exist(self) -> global___ExistenceProof: ...
    @property
    def nonexist(self) -> global___NonExistenceProof: ...
    @property
    def batch(self) -> global___BatchProof: ...
    @property
    def compressed(self) -> global___CompressedBatchProof: ...
    def __init__(self,
        *,
        exist : typing.Optional[global___ExistenceProof] = ...,
        nonexist : typing.Optional[global___NonExistenceProof] = ...,
        batch : typing.Optional[global___BatchProof] = ...,
        compressed : typing.Optional[global___CompressedBatchProof] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"batch",b"batch",u"compressed",b"compressed",u"exist",b"exist",u"nonexist",b"nonexist",u"proof",b"proof"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"batch",b"batch",u"compressed",b"compressed",u"exist",b"exist",u"nonexist",b"nonexist",u"proof",b"proof"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"proof",b"proof"]) -> typing.Optional[typing_extensions.Literal["exist","nonexist","batch","compressed"]]: ...
global___CommitmentProof = CommitmentProof

#*
#LeafOp represents the raw key-value data we wish to prove, and
#must be flexible to represent the internal transformation from
#the original key-value pairs into the basis hash, for many existing
#merkle trees.
#
#key and value are passed in. So that the signature of this operation is:
#leafOp(key, value) -> output
#
#To process this, first prehash the keys and values if needed (ANY means no hash in this case):
#hkey = prehashKey(key)
#hvalue = prehashValue(value)
#
#Then combine the bytes, and hash it
#output = hash(prefix || length(hkey) || hkey || length(hvalue) || hvalue)
class LeafOp(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    HASH_FIELD_NUMBER: builtins.int
    PREHASH_KEY_FIELD_NUMBER: builtins.int
    PREHASH_VALUE_FIELD_NUMBER: builtins.int
    LENGTH_FIELD_NUMBER: builtins.int
    PREFIX_FIELD_NUMBER: builtins.int
    hash: global___HashOp.V = ...
    prehash_key: global___HashOp.V = ...
    prehash_value: global___HashOp.V = ...
    length: global___LengthOp.V = ...
    # prefix is a fixed bytes that may optionally be included at the beginning to differentiate
    # a leaf node from an inner node.
    prefix: builtins.bytes = ...
    def __init__(self,
        *,
        hash : global___HashOp.V = ...,
        prehash_key : global___HashOp.V = ...,
        prehash_value : global___HashOp.V = ...,
        length : global___LengthOp.V = ...,
        prefix : builtins.bytes = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"hash",b"hash",u"length",b"length",u"prefix",b"prefix",u"prehash_key",b"prehash_key",u"prehash_value",b"prehash_value"]) -> None: ...
global___LeafOp = LeafOp

#*
#InnerOp represents a merkle-proof step that is not a leaf.
#It represents concatenating two children and hashing them to provide the next result.
#
#The result of the previous step is passed in, so the signature of this op is:
#innerOp(child) -> output
#
#The result of applying InnerOp should be:
#output = op.hash(op.prefix || child || op.suffix)
#
#where the || operator is concatenation of binary data,
#and child is the result of hashing all the tree below this step.
#
#Any special data, like prepending child with the length, or prepending the entire operation with
#some value to differentiate from leaf nodes, should be included in prefix and suffix.
#If either of prefix or suffix is empty, we just treat it as an empty string
class InnerOp(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    HASH_FIELD_NUMBER: builtins.int
    PREFIX_FIELD_NUMBER: builtins.int
    SUFFIX_FIELD_NUMBER: builtins.int
    hash: global___HashOp.V = ...
    prefix: builtins.bytes = ...
    suffix: builtins.bytes = ...
    def __init__(self,
        *,
        hash : global___HashOp.V = ...,
        prefix : builtins.bytes = ...,
        suffix : builtins.bytes = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"hash",b"hash",u"prefix",b"prefix",u"suffix",b"suffix"]) -> None: ...
global___InnerOp = InnerOp

#*
#ProofSpec defines what the expected parameters are for a given proof type.
#This can be stored in the client and used to validate any incoming proofs.
#
#verify(ProofSpec, Proof) -> Proof | Error
#
#As demonstrated in tests, if we don't fix the algorithm used to calculate the
#LeafHash for a given tree, there are many possible key-value pairs that can
#generate a given hash (by interpretting the preimage differently).
#We need this for proper security, requires client knows a priori what
#tree format server uses. But not in code, rather a configuration object.
class ProofSpec(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    LEAF_SPEC_FIELD_NUMBER: builtins.int
    INNER_SPEC_FIELD_NUMBER: builtins.int
    MAX_DEPTH_FIELD_NUMBER: builtins.int
    MIN_DEPTH_FIELD_NUMBER: builtins.int
    # any field in the ExistenceProof must be the same as in this spec.
    # except Prefix, which is just the first bytes of prefix (spec can be longer)
    @property
    def leaf_spec(self) -> global___LeafOp: ...
    @property
    def inner_spec(self) -> global___InnerSpec: ...
    # max_depth (if > 0) is the maximum number of InnerOps allowed (mainly for fixed-depth tries)
    max_depth: builtins.int = ...
    # min_depth (if > 0) is the minimum number of InnerOps allowed (mainly for fixed-depth tries)
    min_depth: builtins.int = ...
    def __init__(self,
        *,
        leaf_spec : typing.Optional[global___LeafOp] = ...,
        inner_spec : typing.Optional[global___InnerSpec] = ...,
        max_depth : builtins.int = ...,
        min_depth : builtins.int = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"inner_spec",b"inner_spec",u"leaf_spec",b"leaf_spec"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"inner_spec",b"inner_spec",u"leaf_spec",b"leaf_spec",u"max_depth",b"max_depth",u"min_depth",b"min_depth"]) -> None: ...
global___ProofSpec = ProofSpec

#
#InnerSpec contains all store-specific structure info to determine if two proofs from a
#given store are neighbors.
#
#This enables:
#
#isLeftMost(spec: InnerSpec, op: InnerOp)
#isRightMost(spec: InnerSpec, op: InnerOp)
#isLeftNeighbor(spec: InnerSpec, left: InnerOp, right: InnerOp)
class InnerSpec(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    CHILD_ORDER_FIELD_NUMBER: builtins.int
    CHILD_SIZE_FIELD_NUMBER: builtins.int
    MIN_PREFIX_LENGTH_FIELD_NUMBER: builtins.int
    MAX_PREFIX_LENGTH_FIELD_NUMBER: builtins.int
    EMPTY_CHILD_FIELD_NUMBER: builtins.int
    HASH_FIELD_NUMBER: builtins.int
    # Child order is the ordering of the children node, must count from 0
    # iavl tree is [0, 1] (left then right)
    # merk is [0, 2, 1] (left, right, here)
    @property
    def child_order(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]: ...
    child_size: builtins.int = ...
    min_prefix_length: builtins.int = ...
    max_prefix_length: builtins.int = ...
    # empty child is the prehash image that is used when one child is nil (eg. 20 bytes of 0)
    empty_child: builtins.bytes = ...
    # hash is the algorithm that must be used for each InnerOp
    hash: global___HashOp.V = ...
    def __init__(self,
        *,
        child_order : typing.Optional[typing.Iterable[builtins.int]] = ...,
        child_size : builtins.int = ...,
        min_prefix_length : builtins.int = ...,
        max_prefix_length : builtins.int = ...,
        empty_child : builtins.bytes = ...,
        hash : global___HashOp.V = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"child_order",b"child_order",u"child_size",b"child_size",u"empty_child",b"empty_child",u"hash",b"hash",u"max_prefix_length",b"max_prefix_length",u"min_prefix_length",b"min_prefix_length"]) -> None: ...
global___InnerSpec = InnerSpec

#
#BatchProof is a group of multiple proof types than can be compressed
class BatchProof(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ENTRIES_FIELD_NUMBER: builtins.int
    @property
    def entries(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___BatchEntry]: ...
    def __init__(self,
        *,
        entries : typing.Optional[typing.Iterable[global___BatchEntry]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"entries",b"entries"]) -> None: ...
global___BatchProof = BatchProof

# Use BatchEntry not CommitmentProof, to avoid recursion
class BatchEntry(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    EXIST_FIELD_NUMBER: builtins.int
    NONEXIST_FIELD_NUMBER: builtins.int
    @property
    def exist(self) -> global___ExistenceProof: ...
    @property
    def nonexist(self) -> global___NonExistenceProof: ...
    def __init__(self,
        *,
        exist : typing.Optional[global___ExistenceProof] = ...,
        nonexist : typing.Optional[global___NonExistenceProof] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"exist",b"exist",u"nonexist",b"nonexist",u"proof",b"proof"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"exist",b"exist",u"nonexist",b"nonexist",u"proof",b"proof"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"proof",b"proof"]) -> typing.Optional[typing_extensions.Literal["exist","nonexist"]]: ...
global___BatchEntry = BatchEntry

#***** all items here are compressed forms ******

class CompressedBatchProof(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    ENTRIES_FIELD_NUMBER: builtins.int
    LOOKUP_INNERS_FIELD_NUMBER: builtins.int
    @property
    def entries(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___CompressedBatchEntry]: ...
    @property
    def lookup_inners(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___InnerOp]: ...
    def __init__(self,
        *,
        entries : typing.Optional[typing.Iterable[global___CompressedBatchEntry]] = ...,
        lookup_inners : typing.Optional[typing.Iterable[global___InnerOp]] = ...,
        ) -> None: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"entries",b"entries",u"lookup_inners",b"lookup_inners"]) -> None: ...
global___CompressedBatchProof = CompressedBatchProof

# Use BatchEntry not CommitmentProof, to avoid recursion
class CompressedBatchEntry(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    EXIST_FIELD_NUMBER: builtins.int
    NONEXIST_FIELD_NUMBER: builtins.int
    @property
    def exist(self) -> global___CompressedExistenceProof: ...
    @property
    def nonexist(self) -> global___CompressedNonExistenceProof: ...
    def __init__(self,
        *,
        exist : typing.Optional[global___CompressedExistenceProof] = ...,
        nonexist : typing.Optional[global___CompressedNonExistenceProof] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"exist",b"exist",u"nonexist",b"nonexist",u"proof",b"proof"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"exist",b"exist",u"nonexist",b"nonexist",u"proof",b"proof"]) -> None: ...
    def WhichOneof(self, oneof_group: typing_extensions.Literal[u"proof",b"proof"]) -> typing.Optional[typing_extensions.Literal["exist","nonexist"]]: ...
global___CompressedBatchEntry = CompressedBatchEntry

class CompressedExistenceProof(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    KEY_FIELD_NUMBER: builtins.int
    VALUE_FIELD_NUMBER: builtins.int
    LEAF_FIELD_NUMBER: builtins.int
    PATH_FIELD_NUMBER: builtins.int
    key: builtins.bytes = ...
    value: builtins.bytes = ...
    @property
    def leaf(self) -> global___LeafOp: ...
    # these are indexes into the lookup_inners table in CompressedBatchProof
    @property
    def path(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]: ...
    def __init__(self,
        *,
        key : builtins.bytes = ...,
        value : builtins.bytes = ...,
        leaf : typing.Optional[global___LeafOp] = ...,
        path : typing.Optional[typing.Iterable[builtins.int]] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"leaf",b"leaf"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"key",b"key",u"leaf",b"leaf",u"path",b"path",u"value",b"value"]) -> None: ...
global___CompressedExistenceProof = CompressedExistenceProof

class CompressedNonExistenceProof(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor = ...
    KEY_FIELD_NUMBER: builtins.int
    LEFT_FIELD_NUMBER: builtins.int
    RIGHT_FIELD_NUMBER: builtins.int
    # TODO: remove this as unnecessary??? we prove a range
    key: builtins.bytes = ...
    @property
    def left(self) -> global___CompressedExistenceProof: ...
    @property
    def right(self) -> global___CompressedExistenceProof: ...
    def __init__(self,
        *,
        key : builtins.bytes = ...,
        left : typing.Optional[global___CompressedExistenceProof] = ...,
        right : typing.Optional[global___CompressedExistenceProof] = ...,
        ) -> None: ...
    def HasField(self, field_name: typing_extensions.Literal[u"left",b"left",u"right",b"right"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing_extensions.Literal[u"key",b"key",u"left",b"left",u"right",b"right"]) -> None: ...
global___CompressedNonExistenceProof = CompressedNonExistenceProof
